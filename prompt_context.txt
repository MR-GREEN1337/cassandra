## Project Vision and Core Concept
---------------------------------
The project is a full-stack web application named "Cassandra", designed to act as an AI co-pilot for startup founders.

The core premise is to de-risk new ventures by analyzing a user's startup pitch, business plan, or uploaded documents against a knowledge base of 1,000+ startup failures. The AI's goal is to identify potential pitfalls, competitive threats, and market risks, citing its sources with links to the original case studies.

The system is composed of three main parts:
1.  **Data Ingestion Agent ():** A Python-based agentic system that scours the web for startup post-mortems, extracts structured data using an LLM (Gemini 1.5 Pro), generates vector embeddings (OpenAI), and stores everything in a TiDB Serverless database.
2.  **RAG Backend API ():** A Next.js serverless function that receives a user's query and optional file. It performs a hybrid vector + full-text search against the TiDB database to find relevant failure cases. It then uses the Kimi LLM to synthesize this retrieved context and the user's query into a coherent, cited analysis, which is streamed back to the frontend.
3.  **Frontend Interface ():** A spatial, canvas-based UI built with Next.js and React Flow. It allows for a non-linear exploration of ideas. The AI's analysis, complete with favicon-enhanced links to sources, appears in nodes that dynamically resize. Users can create follow-up nodes to explore specific risks in more detail. All sessions are saved to local storage.

Key Features:
- **Hybrid RAG:** Leverages TiDB's vector and full-text search to find both semantically and factually similar failure cases.
- **Source Citation:** The AI is prompted to include Markdown links to the original case studies, which are rendered with favicons in the UI.
- **Spatial Idea Exploration:** Users create and connect nodes on an infinite canvas to visually map out their risk analysis.
- **File Uploads:** Users can upload documents (business plans, etc.) which are parsed by the Kimi API and added to the analysis context.
- **Professional Session Management:** All analysis sessions are saved to , with a sidebar for creating, loading, and deleting sessions.
- **Polished UI:** Includes a minimap, light/dark themes, and a clean aesthetic using Tailwind CSS and Shadcn UI.



## Project File Structure
------------------------
.
├── claude_context.sh
├── components.json
├── data-agent
│   ├── main.py
│   ├── pyproject.toml
│   ├── README.md
│   └── uv.lock
├── eslint.config.mjs
├── LICENSE
├── next-env.d.ts
├── next.config.ts
├── package-lock.json
├── package.json
├── postcss.config.mjs
├── prisma
│   └── schema.prisma
├── prompt_context.txt
├── public
│   ├── aws.png
│   ├── aws.svg
│   ├── dify.png
│   ├── kimi.png
│   ├── sheet0.png
│   └── tidb-logo.svg
├── README.md
├── src
│   ├── app
│   │   ├── (pages)
│   │   │   ├── browse
│   │   │   │   ├── _components
│   │   │   │   │   └── search-input.tsx
│   │   │   │   ├── layout.tsx
│   │   │   │   └── page.tsx
│   │   │   ├── dashboard
│   │   │   │   ├── layout.tsx
│   │   │   │   └── page.tsx
│   │   │   └── page.tsx
│   │   ├── api
│   │   │   └── analyze
│   │   │       └── route.ts
│   │   ├── favicon.ico
│   │   ├── globals.css
│   │   └── layout.tsx
│   ├── components
│   │   ├── CassandraLogo.tsx
│   │   ├── DashboardContext.tsx
│   │   ├── Logo.tsx
│   │   ├── PitchNode.tsx
│   │   ├── theme-provider.tsx
│   │   ├── ThemeToggle.tsx
│   │   └── ui
│   │       ├── avatar.tsx
│   │       ├── badge.tsx
│   │       ├── button.tsx
│   │       ├── card.tsx
│   │       ├── dropdown-menu.tsx
│   │       ├── input.tsx
│   │       ├── scroll-area.tsx
│   │       ├── separator.tsx
│   │       ├── sheet.tsx
│   │       ├── textarea.tsx
│   │       └── tooltip.tsx
│   ├── generated
│   │   └── prisma
│   │       ├── client.d.ts
│   │       ├── client.js
│   │       ├── default.d.ts
│   │       ├── default.js
│   │       ├── edge.d.ts
│   │       ├── edge.js
│   │       ├── index-browser.js
│   │       ├── index.d.ts
│   │       ├── index.js
│   │       ├── libquery_engine-darwin-arm64.dylib.node
│   │       ├── package.json
│   │       ├── runtime
│   │       │   ├── edge-esm.js
│   │       │   ├── edge.js
│   │       │   ├── index-browser.d.ts
│   │       │   ├── index-browser.js
│   │       │   ├── library.d.ts
│   │       │   ├── library.js
│   │       │   ├── react-native.js
│   │       │   ├── wasm-compiler-edge.js
│   │       │   └── wasm-engine-edge.js
│   │       ├── schema.prisma
│   │       ├── wasm.d.ts
│   │       └── wasm.js
│   ├── hooks
│   │   ├── use-audio-input.ts
│   │   └── use-debounce.ts
│   └── lib
│       ├── embedding.ts
│       ├── prisma.ts
│       └── utils.ts
└── tsconfig.json

19 directories, 78 files



## Source Code Files
-------------------

// --- FILE: ./src/generated/prisma/edge.d.ts ---

export * from "./default"
// --- FILE: ./src/generated/prisma/wasm.d.ts ---

export * from "./index"
// --- FILE: ./src/generated/prisma/runtime/library.d.ts ---

/**
 * @param this
 */
declare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;

declare type AccelerateEngineConfig = {
    inlineSchema: EngineConfig['inlineSchema'];
    inlineSchemaHash: EngineConfig['inlineSchemaHash'];
    env: EngineConfig['env'];
    generator?: {
        previewFeatures: string[];
    };
    inlineDatasources: EngineConfig['inlineDatasources'];
    overrideDatasources: EngineConfig['overrideDatasources'];
    clientVersion: EngineConfig['clientVersion'];
    engineVersion: EngineConfig['engineVersion'];
    logEmitter: EngineConfig['logEmitter'];
    logQueries?: EngineConfig['logQueries'];
    logLevel?: EngineConfig['logLevel'];
    tracingHelper: EngineConfig['tracingHelper'];
    accelerateUtils?: AccelerateUtils;
};

/**
 * A stripped down interface of `fetch` that `@prisma/extension-accelerate`
 * relies on. It must be in sync with the corresponding definition in the
 * Accelerate extension.
 *
 * This is the actual interface exposed by the extension. We can't use the
 * custom fetch function provided by it as normal fetch because the API is
 * different. Notably, `headers` must be an object and not a `Headers`
 * instance, and `url` must be a `string` and not a `URL`.
 *
 * The return type is `Response` but we can't specify this in an exported type
 * because it would end up referencing external types from `@types/node` or DOM
 * which can fail typechecking depending on TypeScript configuration in a user's
 * project.
 */
declare type AccelerateExtensionFetch = (url: string, options: {
    body?: string;
    method?: string;
    headers: Record<string, string>;
}) => Promise<unknown>;

declare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;

declare type AccelerateUtils = EngineConfig['accelerateUtils'];

export declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';

declare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;

/**
 * An interface that exposes some basic information about the
 * adapter like its name and provider type.
 */
declare interface AdapterInfo {
    readonly provider: Provider;
    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});
}

export declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';

export declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {
    [P in K]: {
        $allModels: infer AllModels;
    };
} ? {
    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;
} : {};

declare class AnyNull extends NullTypesEnumValue {
    #private;
}

export declare type ApplyOmit<T, OmitConfig> = Compute<{
    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];
}>;

export declare type Args<T, F extends Operation> = T extends {
    [K: symbol]: {
        types: {
            operations: {
                [K in F]: {
                    args: any;
                };
            };
        };
    };
} ? T[symbol]['types']['operations'][F]['args'] : any;

export declare type Args_3<T, F extends Operation> = Args<T, F>;

declare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';

declare type ArgType = {
    scalarType: ArgScalarType;
    dbType?: string;
    arity: Arity;
};

declare type Arity = 'scalar' | 'list';

/**
 * Attributes is a map from string to attribute values.
 *
 * Note: only the own enumerable keys are counted as valid attribute keys.
 */
declare interface Attributes {
    [attributeKey: string]: AttributeValue | undefined;
}

/**
 * Attribute values may be any non-nullish primitive value except an object.
 *
 * null or undefined attribute values are invalid and will result in undefined behavior.
 */
declare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;

export declare type BaseDMMF = {
    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;
};

declare type BatchArgs = {
    queries: BatchQuery[];
    transaction?: {
        isolationLevel?: IsolationLevel_2;
    };
};

declare type BatchInternalParams = {
    requests: RequestParams[];
    customDataProxyFetch?: AccelerateExtensionFetchDecorator;
};

declare type BatchQuery = {
    model: string | undefined;
    operation: string;
    args: JsArgs | RawQueryArgs;
};

declare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;

declare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;

declare type BatchQueryOptionsCbArgs = {
    args: BatchArgs;
    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;
    __internalParams: BatchInternalParams;
};

declare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;

declare type BatchTransactionOptions = {
    isolationLevel?: Transaction_2.IsolationLevel;
};

declare interface BinaryTargetsEnvValue {
    fromEnvVar: string | null;
    value: string;
    native?: boolean;
}

export declare type Call<F extends Fn, P> = (F & {
    params: P;
})['returns'];

declare interface CallSite {
    getLocation(): LocationInFile | null;
}

export declare type Cast<A, W> = A extends W ? A : W;

declare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;

export declare type ClientArg = {
    [MethodName in string]: unknown;
};

export declare type ClientArgs = {
    client: ClientArg;
};

export declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;

export declare type ClientOptionDef = undefined | {
    [K in string]: any;
};

export declare type ClientOtherOps = {
    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;
    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;
    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;
    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;
    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;
    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;
};

declare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];

declare const ColumnTypeEnum: {
    readonly Int32: 0;
    readonly Int64: 1;
    readonly Float: 2;
    readonly Double: 3;
    readonly Numeric: 4;
    readonly Boolean: 5;
    readonly Character: 6;
    readonly Text: 7;
    readonly Date: 8;
    readonly Time: 9;
    readonly DateTime: 10;
    readonly Json: 11;
    readonly Enum: 12;
    readonly Bytes: 13;
    readonly Set: 14;
    readonly Uuid: 15;
    readonly Int32Array: 64;
    readonly Int64Array: 65;
    readonly FloatArray: 66;
    readonly DoubleArray: 67;
    readonly NumericArray: 68;
    readonly BooleanArray: 69;
    readonly CharacterArray: 70;
    readonly TextArray: 71;
    readonly DateArray: 72;
    readonly TimeArray: 73;
    readonly DateTimeArray: 74;
    readonly JsonArray: 75;
    readonly EnumArray: 76;
    readonly BytesArray: 77;
    readonly UuidArray: 78;
    readonly UnknownNumber: 128;
};

declare type CompactedBatchResponse = {
    type: 'compacted';
    plan: QueryPlanNode;
    arguments: Record<string, {}>[];
    nestedSelection: string[];
    keys: string[];
    expectNonEmpty: boolean;
};

declare type CompilerWasmLoadingConfig = {
    /**
     * WASM-bindgen runtime for corresponding module
     */
    getRuntime: () => Promise<{
        __wbg_set_wasm(exports: unknown): void;
        QueryCompiler: QueryCompilerConstructor;
    }>;
    /**
     * Loads the raw wasm module for the wasm compiler engine. This configuration is
     * generated specifically for each type of client, eg. Node.js client and Edge
     * clients will have different implementations.
     * @remarks this is a callback on purpose, we only load the wasm if needed.
     * @remarks only used by ClientEngine
     */
    getQueryCompilerWasmModule: () => Promise<unknown>;
};

export declare type Compute<T> = T extends Function ? T : {
    [K in keyof T]: T[K];
} & unknown;

export declare type ComputeDeep<T> = T extends Function ? T : {
    [K in keyof T]: ComputeDeep<T[K]>;
} & unknown;

declare type ComputedField = {
    name: string;
    needs: string[];
    compute: ResultArgsFieldCompute;
};

declare type ComputedFieldsMap = {
    [fieldName: string]: ComputedField;
};

declare type ConnectionInfo = {
    schemaName?: string;
    maxBindValues?: number;
    supportsRelationJoins: boolean;
};

declare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';

declare interface Context {
    /**
     * Get a value from the context.
     *
     * @param key key which identifies a context value
     */
    getValue(key: symbol): unknown;
    /**
     * Create a new context which inherits from this context and has
     * the given key set to the given value.
     *
     * @param key context key for which to set the value
     * @param value value to set for the given key
     */
    setValue(key: symbol, value: unknown): Context;
    /**
     * Return a new context which inherits from this context but does
     * not contain a value for the given key.
     *
     * @param key context key for which to clear a value
     */
    deleteValue(key: symbol): Context;
}

declare type Context_2<T> = T extends {
    [K: symbol]: {
        ctx: infer C;
    };
} ? C & T & {
    /**
     * @deprecated Use `$name` instead.
     */
    name?: string;
    $name?: string;
    $parent?: unknown;
} : T & {
    /**
     * @deprecated Use `$name` instead.
     */
    name?: string;
    $name?: string;
    $parent?: unknown;
};

export declare type Count<O> = {
    [K in keyof O]: Count<number>;
} & {};

export declare function createParam(name: string): Param<unknown, string>;

declare class DataLoader<T = unknown> {
    private options;
    batches: {
        [key: string]: Job[];
    };
    private tickActive;
    constructor(options: DataLoaderOptions<T>);
    request(request: T): Promise<any>;
    private dispatchBatches;
    get [Symbol.toStringTag](): string;
}

declare type DataLoaderOptions<T> = {
    singleLoader: (request: T) => Promise<any>;
    batchLoader: (request: T[]) => Promise<any[]>;
    batchBy: (request: T) => string | undefined;
    batchOrder: (requestA: T, requestB: T) => number;
};

declare type Datamodel = ReadonlyDeep_2<{
    models: Model[];
    enums: DatamodelEnum[];
    types: Model[];
    indexes: Index[];
}>;

declare type DatamodelEnum = ReadonlyDeep_2<{
    name: string;
    values: EnumValue[];
    dbName?: string | null;
    documentation?: string;
}>;

declare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;

declare type DataRule = {
    type: 'rowCountEq';
    args: number;
} | {
    type: 'rowCountNeq';
    args: number;
} | {
    type: 'affectedRowCountEq';
    args: number;
} | {
    type: 'never';
};

declare type Datasource = {
    url?: string;
};

declare type Datasources = {
    [name in string]: Datasource;
};

declare class DbNull extends NullTypesEnumValue {
    #private;
}

export declare const Debug: typeof debugCreate & {
    enable(namespace: any): void;
    disable(): any;
    enabled(namespace: string): boolean;
    log: (...args: string[]) => void;
    formatters: {};
};

/**
 * Create a new debug instance with the given namespace.
 *
 * @example
 * ```ts
 * import Debug from '@prisma/debug'
 * const debug = Debug('prisma:client')
 * debug('Hello World')
 * ```
 */
declare function debugCreate(namespace: string): ((...args: any[]) => void) & {
    color: string;
    enabled: boolean;
    namespace: string;
    log: (...args: string[]) => void;
    extend: () => void;
};

export declare function Decimal(n: Decimal.Value): Decimal;

export declare namespace Decimal {
    export type Constructor = typeof Decimal;
    export type Instance = Decimal;
    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
    export type Modulo = Rounding | 9;
    export type Value = string | number | Decimal;

    // http://mikemcl.github.io/decimal.js/#constructor-properties
    export interface Config {
        precision?: number;
        rounding?: Rounding;
        toExpNeg?: number;
        toExpPos?: number;
        minE?: number;
        maxE?: number;
        crypto?: boolean;
        modulo?: Modulo;
        defaults?: boolean;
    }
}

export declare class Decimal {
    readonly d: number[];
    readonly e: number;
    readonly s: number;

    constructor(n: Decimal.Value);

    absoluteValue(): Decimal;
    abs(): Decimal;

    ceil(): Decimal;

    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;
    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;

    comparedTo(n: Decimal.Value): number;
    cmp(n: Decimal.Value): number;

    cosine(): Decimal;
    cos(): Decimal;

    cubeRoot(): Decimal;
    cbrt(): Decimal;

    decimalPlaces(): number;
    dp(): number;

    dividedBy(n: Decimal.Value): Decimal;
    div(n: Decimal.Value): Decimal;

    dividedToIntegerBy(n: Decimal.Value): Decimal;
    divToInt(n: Decimal.Value): Decimal;

    equals(n: Decimal.Value): boolean;
    eq(n: Decimal.Value): boolean;

    floor(): Decimal;

    greaterThan(n: Decimal.Value): boolean;
    gt(n: Decimal.Value): boolean;

    greaterThanOrEqualTo(n: Decimal.Value): boolean;
    gte(n: Decimal.Value): boolean;

    hyperbolicCosine(): Decimal;
    cosh(): Decimal;

    hyperbolicSine(): Decimal;
    sinh(): Decimal;

    hyperbolicTangent(): Decimal;
    tanh(): Decimal;

    inverseCosine(): Decimal;
    acos(): Decimal;

    inverseHyperbolicCosine(): Decimal;
    acosh(): Decimal;

    inverseHyperbolicSine(): Decimal;
    asinh(): Decimal;

    inverseHyperbolicTangent(): Decimal;
    atanh(): Decimal;

    inverseSine(): Decimal;
    asin(): Decimal;

    inverseTangent(): Decimal;
    atan(): Decimal;

    isFinite(): boolean;

    isInteger(): boolean;
    isInt(): boolean;

    isNaN(): boolean;

    isNegative(): boolean;
    isNeg(): boolean;

    isPositive(): boolean;
    isPos(): boolean;

    isZero(): boolean;

    lessThan(n: Decimal.Value): boolean;
    lt(n: Decimal.Value): boolean;

    lessThanOrEqualTo(n: Decimal.Value): boolean;
    lte(n: Decimal.Value): boolean;

    logarithm(n?: Decimal.Value): Decimal;
    log(n?: Decimal.Value): Decimal;

    minus(n: Decimal.Value): Decimal;
    sub(n: Decimal.Value): Decimal;

    modulo(n: Decimal.Value): Decimal;
    mod(n: Decimal.Value): Decimal;

    naturalExponential(): Decimal;
    exp(): Decimal;

    naturalLogarithm(): Decimal;
    ln(): Decimal;

    negated(): Decimal;
    neg(): Decimal;

    plus(n: Decimal.Value): Decimal;
    add(n: Decimal.Value): Decimal;

    precision(includeZeros?: boolean): number;
    sd(includeZeros?: boolean): number;

    round(): Decimal;

    sine() : Decimal;
    sin() : Decimal;

    squareRoot(): Decimal;
    sqrt(): Decimal;

    tangent() : Decimal;
    tan() : Decimal;

    times(n: Decimal.Value): Decimal;
    mul(n: Decimal.Value) : Decimal;

    toBinary(significantDigits?: number): string;
    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;

    toDecimalPlaces(decimalPlaces?: number): Decimal;
    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;
    toDP(decimalPlaces?: number): Decimal;
    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;

    toExponential(decimalPlaces?: number): string;
    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;

    toFixed(decimalPlaces?: number): string;
    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;

    toFraction(max_denominator?: Decimal.Value): Decimal[];

    toHexadecimal(significantDigits?: number): string;
    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;
    toHex(significantDigits?: number): string;
    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;

    toJSON(): string;

    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;

    toNumber(): number;

    toOctal(significantDigits?: number): string;
    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;

    toPower(n: Decimal.Value): Decimal;
    pow(n: Decimal.Value): Decimal;

    toPrecision(significantDigits?: number): string;
    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;

    toSignificantDigits(significantDigits?: number): Decimal;
    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;
    toSD(significantDigits?: number): Decimal;
    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;

    toString(): string;

    truncated(): Decimal;
    trunc(): Decimal;

    valueOf(): string;

    static abs(n: Decimal.Value): Decimal;
    static acos(n: Decimal.Value): Decimal;
    static acosh(n: Decimal.Value): Decimal;
    static add(x: Decimal.Value, y: Decimal.Value): Decimal;
    static asin(n: Decimal.Value): Decimal;
    static asinh(n: Decimal.Value): Decimal;
    static atan(n: Decimal.Value): Decimal;
    static atanh(n: Decimal.Value): Decimal;
    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;
    static cbrt(n: Decimal.Value): Decimal;
    static ceil(n: Decimal.Value): Decimal;
    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;
    static clone(object?: Decimal.Config): Decimal.Constructor;
    static config(object: Decimal.Config): Decimal.Constructor;
    static cos(n: Decimal.Value): Decimal;
    static cosh(n: Decimal.Value): Decimal;
    static div(x: Decimal.Value, y: Decimal.Value): Decimal;
    static exp(n: Decimal.Value): Decimal;
    static floor(n: Decimal.Value): Decimal;
    static hypot(...n: Decimal.Value[]): Decimal;
    static isDecimal(object: any): object is Decimal;
    static ln(n: Decimal.Value): Decimal;
    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;
    static log2(n: Decimal.Value): Decimal;
    static log10(n: Decimal.Value): Decimal;
    static max(...n: Decimal.Value[]): Decimal;
    static min(...n: Decimal.Value[]): Decimal;
    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;
    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;
    static noConflict(): Decimal.Constructor;   // Browser only
    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;
    static random(significantDigits?: number): Decimal;
    static round(n: Decimal.Value): Decimal;
    static set(object: Decimal.Config): Decimal.Constructor;
    static sign(n: Decimal.Value): number;
    static sin(n: Decimal.Value): Decimal;
    static sinh(n: Decimal.Value): Decimal;
    static sqrt(n: Decimal.Value): Decimal;
    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;
    static sum(...n: Decimal.Value[]): Decimal;
    static tan(n: Decimal.Value): Decimal;
    static tanh(n: Decimal.Value): Decimal;
    static trunc(n: Decimal.Value): Decimal;

    static readonly default?: Decimal.Constructor;
    static readonly Decimal?: Decimal.Constructor;

    static readonly precision: number;
    static readonly rounding: Decimal.Rounding;
    static readonly toExpNeg: number;
    static readonly toExpPos: number;
    static readonly minE: number;
    static readonly maxE: number;
    static readonly crypto: boolean;
    static readonly modulo: Decimal.Modulo;

    static readonly ROUND_UP: 0;
    static readonly ROUND_DOWN: 1;
    static readonly ROUND_CEIL: 2;
    static readonly ROUND_FLOOR: 3;
    static readonly ROUND_HALF_UP: 4;
    static readonly ROUND_HALF_DOWN: 5;
    static readonly ROUND_HALF_EVEN: 6;
    static readonly ROUND_HALF_CEIL: 7;
    static readonly ROUND_HALF_FLOOR: 8;
    static readonly EUCLID: 9;
}

/**
 * Interface for any Decimal.js-like library
 * Allows us to accept Decimal.js from different
 * versions and some compatible alternatives
 */
export declare interface DecimalJsLike {
    d: number[];
    e: number;
    s: number;
    toFixed(): string;
}

export declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;

export declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {
    omit: infer LocalOmit;
} ? ApplyOmit<UnwrapPayload<{
    default: Payload;
}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{
    default: Payload;
}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;

export declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;

declare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;

declare const denylist: readonly ["$connect", "$disconnect", "$on", "$transaction", "$extends"];

declare type Deprecation = ReadonlyDeep_2<{
    sinceVersion: string;
    reason: string;
    plannedRemovalVersion?: string;
}>;

declare type DeserializedResponse = Array<Record<string, unknown>>;

export declare function deserializeJsonResponse(result: unknown): unknown;

export declare function deserializeRawResult(response: RawResponse): DeserializedResponse;

export declare type DevTypeMapDef = {
    meta: {
        modelProps: string;
    };
    model: {
        [Model in PropertyKey]: {
            [Operation in PropertyKey]: DevTypeMapFnDef;
        };
    };
    other: {
        [Operation in PropertyKey]: DevTypeMapFnDef;
    };
};

export declare type DevTypeMapFnDef = {
    args: any;
    result: any;
    payload: OperationPayload;
};

export declare namespace DMMF {
    export {
        datamodelEnumToSchemaEnum,
        Document_2 as Document,
        Mappings,
        OtherOperationMappings,
        DatamodelEnum,
        SchemaEnum,
        EnumValue,
        Datamodel,
        uniqueIndex,
        PrimaryKey,
        Model,
        FieldKind,
        FieldNamespace,
        FieldLocation,
        Field,
        FieldDefault,
        FieldDefaultScalar,
        Index,
        IndexType,
        IndexField,
        SortOrder,
        Schema,
        Query,
        QueryOutput,
        TypeRef,
        InputTypeRef,
        SchemaArg,
        OutputType,
        SchemaField,
        OutputTypeRef,
        Deprecation,
        InputType,
        FieldRefType,
        FieldRefAllowType,
        ModelMapping,
        ModelAction
    }
}

declare namespace DMMF_2 {
    export {
        datamodelEnumToSchemaEnum,
        Document_2 as Document,
        Mappings,
        OtherOperationMappings,
        DatamodelEnum,
        SchemaEnum,
        EnumValue,
        Datamodel,
        uniqueIndex,
        PrimaryKey,
        Model,
        FieldKind,
        FieldNamespace,
        FieldLocation,
        Field,
        FieldDefault,
        FieldDefaultScalar,
        Index,
        IndexType,
        IndexField,
        SortOrder,
        Schema,
        Query,
        QueryOutput,
        TypeRef,
        InputTypeRef,
        SchemaArg,
        OutputType,
        SchemaField,
        OutputTypeRef,
        Deprecation,
        InputType,
        FieldRefType,
        FieldRefAllowType,
        ModelMapping,
        ModelAction
    }
}

export declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;

declare type Document_2 = ReadonlyDeep_2<{
    datamodel: Datamodel;
    schema: Schema;
    mappings: Mappings;
}>;

/**
 * A generic driver adapter factory that allows the user to instantiate a
 * driver adapter. The query and result types are specific to the adapter.
 */
declare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {
    /**
     * Instantiate a driver adapter.
     */
    connect(): Promise<Queryable<Query, Result>>;
}

declare type DynamicArgType = ArgType | {
    arity: 'tuple';
    elements: ArgType[];
};

/** Client */
export declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {
    [P in keyof C_]: unknown;
} & {
    [K: symbol]: {
        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {
            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;
        };
    };
};

export declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {
    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;
} & {
    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;
} & {
    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;
} & {
    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];
} & {
    [K: symbol]: {
        types: TypeMap['other'];
    };
};

export declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {
    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {
        extArgs: ExtArgs;
    }>>;
    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {
        isolationLevel?: TypeMap['meta']['txIsolationLevel'];
    }): Promise<UnwrapTuple<P>>;
    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {
        maxWait?: number;
        timeout?: number;
        isolationLevel?: TypeMap['meta']['txIsolationLevel'];
    }): Promise<R>;
    $disconnect(): Promise<void>;
    $connect(): Promise<void>;
};

/** Model */
export declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {
    [K in keyof M_]: K extends '$allModels' ? {
        [P in keyof M_[K]]?: unknown;
    } & {
        [K: symbol]: {};
    } : K extends TypeMap['meta']['modelProps'] ? {
        [P in keyof M_[K]]?: unknown;
    } & {
        [K: symbol]: {
            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {
                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;
            } & {
                $name: ModelKey<TypeMap, K>;
            } & {
                /**
                 * @deprecated Use `$name` instead.
                 */
                name: ModelKey<TypeMap, K>;
            };
        };
    } : never;
};

export declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {
    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {
        select: {
            [P in K]: A;
        };
    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;
};

export declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;

export declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;

export declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;

export declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;

export declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {
    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;
} & {
    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;
} & {
    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];
} & {
    [K: symbol]: {
        types: TypeMap['model'][M];
    };
};

/** Query */
export declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {
    [K in keyof Q_]: K extends '$allOperations' ? (args: {
        model?: string;
        operation: string;
        args: any;
        query: (args: any) => PrismaPromise<any>;
    }) => Promise<any> : K extends '$allModels' ? {
        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;
    } : K extends TypeMap['meta']['modelProps'] ? {
        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;
    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;
};

export declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;

export declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {
    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;
    model: _0 extends 0 ? undefined : _1;
    operation: _2;
    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;
} : never : never) & {
    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;
};

export declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];

/** Result */
export declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {
    [K in keyof R_]: {
        [P in keyof R_[K]]?: {
            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;
            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;
        };
    };
};

export declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {
    select: S;
}, {}>;

export declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {
    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;
} & {
    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;
};

/**
 * Placeholder value for "no text".
 */
export declare const empty: Sql;

export declare type EmptyToUnknown<T> = T;

declare interface Engine<InteractiveTransactionPayload = unknown> {
    /** The name of the engine. This is meant to be consumed externally */
    readonly name: string;
    onBeforeExit(callback: () => Promise<void>): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    version(forceRun?: boolean): Promise<string> | string;
    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;
    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;
    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;
    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;
    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;
    metrics(options: MetricsOptionsJson): Promise<Metrics>;
    metrics(options: MetricsOptionsPrometheus): Promise<string>;
    applyPendingMigrations(): Promise<void>;
}

declare interface EngineConfig {
    cwd: string;
    dirname: string;
    enableDebugLogs?: boolean;
    allowTriggerPanic?: boolean;
    prismaPath?: string;
    generator?: GeneratorConfig;
    /**
     * @remarks this field is used internally by Policy, do not rename or remove
     */
    overrideDatasources: Datasources;
    showColors?: boolean;
    logQueries?: boolean;
    logLevel?: 'info' | 'warn';
    env: Record<string, string>;
    flags?: string[];
    clientVersion: string;
    engineVersion: string;
    previewFeatures?: string[];
    engineEndpoint?: string;
    activeProvider?: string;
    logEmitter: LogEmitter;
    transactionOptions: Transaction_2.Options;
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.
     * If set, this is only used in the library engine, and all queries would be performed through it,
     * rather than Prisma's Rust drivers.
     * @remarks only used by LibraryEngine.ts
     */
    adapter?: SqlDriverAdapterFactory;
    /**
     * The contents of the schema encoded into a string
     */
    inlineSchema: string;
    /**
     * The contents of the datasource url saved in a string
     * @remarks only used by DataProxyEngine.ts
     * @remarks this field is used internally by Policy, do not rename or remove
     */
    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];
    /**
     * The string hash that was produced for a given schema
     * @remarks only used by DataProxyEngine.ts
     */
    inlineSchemaHash: string;
    /**
     * The helper for interaction with OTEL tracing
     * @remarks enabling is determined by the client and @prisma/instrumentation package
     */
    tracingHelper: TracingHelper;
    /**
     * Information about whether we have not found a schema.prisma file in the
     * default location, and that we fell back to finding the schema.prisma file
     * in the current working directory. This usually means it has been bundled.
     */
    isBundled?: boolean;
    /**
     * Web Assembly module loading configuration
     */
    engineWasm?: EngineWasmLoadingConfig;
    compilerWasm?: CompilerWasmLoadingConfig;
    /**
     * Allows Accelerate to use runtime utilities from the client. These are
     * necessary for the AccelerateEngine to function correctly.
     */
    accelerateUtils?: {
        resolveDatasourceUrl: typeof resolveDatasourceUrl;
        getBatchRequestPayload: typeof getBatchRequestPayload;
        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;
        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;
        PrismaClientInitializationError: typeof PrismaClientInitializationError;
        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;
        debug: (...args: any[]) => void;
        engineVersion: string;
        clientVersion: string;
    };
}

declare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;

declare type EngineEventType = QueryEventType | LogEventType;

declare type EngineSpan = {
    id: EngineSpanId;
    parentId: string | null;
    name: string;
    startTime: HrTime;
    endTime: HrTime;
    kind: EngineSpanKind;
    attributes?: Record<string, unknown>;
    links?: EngineSpanId[];
};

declare type EngineSpanId = string;

declare type EngineSpanKind = 'client' | 'internal';

declare type EngineWasmLoadingConfig = {
    /**
     * WASM-bindgen runtime for corresponding module
     */
    getRuntime: () => Promise<{
        __wbg_set_wasm(exports: unknown): void;
        QueryEngine: QueryEngineConstructor;
    }>;
    /**
     * Loads the raw wasm module for the wasm query engine. This configuration is
     * generated specifically for each type of client, eg. Node.js client and Edge
     * clients will have different implementations.
     * @remarks this is a callback on purpose, we only load the wasm if needed.
     * @remarks only used by LibraryEngine
     */
    getQueryEngineWasmModule: () => Promise<unknown>;
};

declare type EnumValue = ReadonlyDeep_2<{
    name: string;
    dbName: string | null;
}>;

declare type EnvPaths = {
    rootEnvPath: string | null;
    schemaEnvPath: string | undefined;
};

declare interface EnvValue {
    fromEnvVar: null | string;
    value: null | string;
}

export declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;

declare type Error_2 = MappedError & {
    originalCode?: string;
    originalMessage?: string;
};

declare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;

declare type ErrorCapturingInterface<T> = {
    [K in keyof T]: ErrorCapturingFunction<T[K]>;
};

declare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {
    readonly errorRegistry: ErrorRegistry;
}

declare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';

declare type ErrorRecord = {
    error: unknown;
};

declare interface ErrorRegistry {
    consumeError(id: number): ErrorRecord | undefined;
}

declare interface ErrorWithBatchIndex {
    batchRequestIdx?: number;
}

declare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;

export declare type Exact<A, W> = (A extends unknown ? (W extends A ? {
    [K in keyof A]: Exact<A[K], W[K]>;
} : W) : never) | (A extends Narrowable ? A : never);

/**
 * Defines Exception.
 *
 * string or an object with one of (message or name or code) and optional stack
 */
declare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;

declare interface ExceptionWithCode {
    code: string | number;
    name?: string;
    message?: string;
    stack?: string;
}

declare interface ExceptionWithMessage {
    code?: string | number;
    message: string;
    name?: string;
    stack?: string;
}

declare interface ExceptionWithName {
    code?: string | number;
    message?: string;
    name: string;
    stack?: string;
}

declare type ExtendedEventType = LogLevel | 'beforeExit';

declare type ExtendedSpanOptions = SpanOptions & {
    /** The name of the span */
    name: string;
    internal?: boolean;
    /** Whether it propagates context (?=true) */
    active?: boolean;
    /** The context to append the span to */
    context?: Context;
};

/** $extends, defineExtension */
export declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {
    extArgs: ExtArgs;
}>> {
    extArgs: ExtArgs;
    <R_ extends {
        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;
    }, R, M_ extends {
        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;
    }, M, Q_ extends {
        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;
    }, C_ extends {
        [K in string]?: unknown;
    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {
        $extends: {
            extArgs: Args;
        };
    }) | {
        name?: string;
        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;
        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;
        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;
        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;
    }): {
        extends: DynamicClientExtensionThis<Call<TypeMapCb, {
            extArgs: MergedArgs;
        }>, TypeMapCb, MergedArgs>;
        define: (client: any) => {
            $extends: {
                extArgs: Args;
            };
        };
    }[Variant];
}

export declare type ExtensionArgs = Optional<RequiredExtensionArgs>;

declare namespace Extensions {
    export {
        defineExtension,
        getExtensionContext
    }
}
export { Extensions }

declare namespace Extensions_2 {
    export {
        InternalArgs,
        DefaultArgs,
        GetPayloadResultExtensionKeys,
        GetPayloadResultExtensionObject,
        GetPayloadResult,
        GetSelect,
        GetOmit,
        DynamicQueryExtensionArgs,
        DynamicQueryExtensionCb,
        DynamicQueryExtensionCbArgs,
        DynamicQueryExtensionCbArgsArgs,
        DynamicResultExtensionArgs,
        DynamicResultExtensionNeeds,
        DynamicResultExtensionData,
        DynamicModelExtensionArgs,
        DynamicModelExtensionThis,
        DynamicModelExtensionOperationFn,
        DynamicModelExtensionFnResult,
        DynamicModelExtensionFnResultBase,
        DynamicModelExtensionFluentApi,
        DynamicModelExtensionFnResultNull,
        DynamicClientExtensionArgs,
        DynamicClientExtensionThis,
        ClientBuiltInProp,
        DynamicClientExtensionThisBuiltin,
        ExtendsHook,
        MergeExtArgs,
        AllModelsToStringIndex,
        TypeMapDef,
        DevTypeMapDef,
        DevTypeMapFnDef,
        ClientOptionDef,
        ClientOtherOps,
        TypeMapCbDef,
        ModelKey,
        RequiredExtensionArgs as UserArgs
    }
}

export declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {
    omit: {
        [K in ModelName]: infer GlobalOmit;
    };
} ? GlobalOmit : {};

declare type Field = ReadonlyDeep_2<{
    kind: FieldKind;
    name: string;
    isRequired: boolean;
    isList: boolean;
    isUnique: boolean;
    isId: boolean;
    isReadOnly: boolean;
    isGenerated?: boolean;
    isUpdatedAt?: boolean;
    /**
     * Describes the data type in the same the way it is defined in the Prisma schema:
     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName
     */
    type: string;
    /**
     * Native database type, if specified.
     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,
     * `@db.Text` is encoded as `['Text', []]`.
     */
    nativeType?: [string, string[]] | null;
    dbName?: string | null;
    hasDefaultValue: boolean;
    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];
    relationFromFields?: string[];
    relationToFields?: string[];
    relationOnDelete?: string;
    relationOnUpdate?: string;
    relationName?: string;
    documentation?: string;
}>;

declare type FieldDefault = ReadonlyDeep_2<{
    name: string;
    args: Array<string | number>;
}>;

declare type FieldDefaultScalar = string | boolean | number;

declare type FieldInitializer = {
    type: 'value';
    value: PrismaValue;
} | {
    type: 'lastInsertId';
};

declare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';

declare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';

declare type FieldNamespace = 'model' | 'prisma';

declare type FieldOperation = {
    type: 'set';
    value: PrismaValue;
} | {
    type: 'add';
    value: PrismaValue;
} | {
    type: 'subtract';
    value: PrismaValue;
} | {
    type: 'multiply';
    value: PrismaValue;
} | {
    type: 'divide';
    value: PrismaValue;
};

/**
 * A reference to a specific field of a specific model
 */
export declare interface FieldRef<Model, FieldType> {
    readonly modelName: Model;
    readonly name: string;
    readonly typeName: FieldType;
    readonly isList: boolean;
}

declare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;

declare type FieldRefType = ReadonlyDeep_2<{
    name: string;
    allowTypes: FieldRefAllowType[];
    fields: SchemaArg[];
}>;

declare type FieldScalarType = {
    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';
} | {
    type: 'enum';
    name: string;
} | {
    type: 'bytes';
    encoding: 'array' | 'base64' | 'hex';
};

declare type FieldType = {
    arity: Arity;
} & FieldScalarType;

declare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';

export declare interface Fn<Params = unknown, Returns = unknown> {
    params: Params;
    returns: Returns;
}

declare type Fragment = {
    type: 'stringChunk';
    chunk: string;
} | {
    type: 'parameter';
} | {
    type: 'parameterTuple';
} | {
    type: 'parameterTupleList';
    itemPrefix: string;
    itemSeparator: string;
    itemSuffix: string;
    groupSeparator: string;
};

declare interface GeneratorConfig {
    name: string;
    output: EnvValue | null;
    isCustomOutput?: boolean;
    provider: EnvValue;
    config: {
        /** `output` is a reserved name and will only be available directly at `generator.output` */
        output?: never;
        /** `provider` is a reserved name and will only be available directly at `generator.provider` */
        provider?: never;
        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */
        binaryTargets?: never;
        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */
        previewFeatures?: never;
    } & {
        [key: string]: string | string[] | undefined;
    };
    binaryTargets: BinaryTargetsEnvValue[];
    previewFeatures: string[];
    envPaths?: EnvPaths;
    sourceFilePath: string;
}

export declare type GetAggregateResult<P extends OperationPayload, A> = {
    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {
        [J in keyof A[K] & string]: P['scalars'][J] | null;
    };
};

declare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;

export declare type GetBatchResult = {
    count: number;
};

export declare type GetCountResult<A> = A extends {
    select: infer S;
} ? (S extends true ? number : Count<S>) : number;

declare function getExtensionContext<T>(that: T): Context_2<T>;

export declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {
    select: infer S extends object;
} & Record<string, unknown> | {
    include: infer I extends object;
} & Record<string, unknown> ? {
    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {
        scalars: {
            [k in K]: infer O;
        };
    } ? O : K extends '_count' ? Count<P['objects']> : never;
} & (A extends {
    include: any;
} & Record<string, unknown> ? DefaultSelection<P, A & {
    omit: A['omit'];
}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;

export declare type GetGroupByResult<P extends OperationPayload, A> = A extends {
    by: string[];
} ? Array<GetAggregateResult<P, A> & {
    [K in A['by'][number]]: P['scalars'][K];
}> : A extends {
    by: string;
} ? Array<GetAggregateResult<P, A> & {
    [K in A['by']]: P['scalars'][K];
}> : {}[];

export declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {
    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;
};

export declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;

export declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;

export declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {
    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {
        compute: (...args: any) => infer C;
    } ? C : never;
};

export declare function getPrismaClient(config: GetPrismaClientConfig): {
    new (optionsArg?: PrismaClientOptions): {
        _originalClient: any;
        _runtimeDataModel: RuntimeDataModel;
        _requestHandler: RequestHandler;
        _connectionPromise?: Promise<any> | undefined;
        _disconnectionPromise?: Promise<any> | undefined;
        _engineConfig: EngineConfig;
        _accelerateEngineConfig: AccelerateEngineConfig;
        _clientVersion: string;
        _errorFormat: ErrorFormat;
        _tracingHelper: TracingHelper;
        _previewFeatures: string[];
        _activeProvider: string;
        _globalOmit?: GlobalOmitOptions | undefined;
        _extensions: MergedExtensionsList;
        /**
         * @remarks This is used internally by Policy, do not rename or remove
         */
        _engine: Engine;
        /**
         * A fully constructed/applied Client that references the parent
         * PrismaClient. This is used for Client extensions only.
         */
        _appliedParent: any;
        _createPrismaPromise: PrismaPromiseFactory;
        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;
        $connect(): Promise<void>;
        /**
         * Disconnect from the database
         */
        $disconnect(): Promise<void>;
        /**
         * Executes a raw query and always returns a number
         */
        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;
        /**
         * Executes a raw query provided through a safe tag function
         * @see https://github.com/prisma/prisma/issues/7142
         *
         * @param query
         * @param values
         * @returns
         */
        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;
        /**
         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections
         * @see https://github.com/prisma/prisma/issues/7142
         *
         * @param query
         * @param values
         * @returns
         */
        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;
        /**
         * Executes a raw command only for MongoDB
         *
         * @param command
         * @returns
         */
        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;
        /**
         * Executes a raw query and returns selected data
         */
        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;
        /**
         * Executes a raw query provided through a safe tag function
         * @see https://github.com/prisma/prisma/issues/7142
         *
         * @param query
         * @param values
         * @returns
         */
        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;
        /**
         * Counterpart to $queryRaw, that returns strongly typed results
         * @param typedSql
         */
        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;
        /**
         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections
         * @see https://github.com/prisma/prisma/issues/7142
         *
         * @param query
         * @param values
         * @returns
         */
        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;
        /**
         * Execute a batch of requests in a transaction
         * @param requests
         * @param options
         */
        _transactionWithArray({ promises, options, }: {
            promises: Array<PrismaPromise_2<any>>;
            options?: BatchTransactionOptions;
        }): Promise<any>;
        /**
         * Perform a long-running transaction
         * @param callback
         * @param options
         * @returns
         */
        _transactionWithCallback({ callback, options, }: {
            callback: (client: Client) => Promise<unknown>;
            options?: Options;
        }): Promise<unknown>;
        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;
        /**
         * Execute queries within a transaction
         * @param input a callback or a query list
         * @param options to set timeouts (callback)
         * @returns
         */
        $transaction(input: any, options?: any): Promise<any>;
        /**
         * Runs the middlewares over params before executing a request
         * @param internalParams
         * @returns
         */
        _request(internalParams: InternalRequestParams): Promise<any>;
        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;
        $metrics: MetricsClient;
        /**
         * Shortcut for checking a preview flag
         * @param feature preview flag
         * @returns
         */
        _hasPreviewFlag(feature: string): boolean;
        $applyPendingMigrations(): Promise<void>;
        $extends: typeof $extends;
        readonly [Symbol.toStringTag]: string;
    };
};

/**
 * Config that is stored into the generated client. When the generated client is
 * loaded, this same config is passed to {@link getPrismaClient} which creates a
 * closure with that config around a non-instantiated [[PrismaClient]].
 */
export declare type GetPrismaClientConfig = {
    runtimeDataModel: RuntimeDataModel;
    generator?: GeneratorConfig;
    relativeEnvPaths?: {
        rootEnvPath?: string | null;
        schemaEnvPath?: string | null;
    };
    relativePath: string;
    dirname: string;
    clientVersion: string;
    engineVersion: string;
    datasourceNames: string[];
    activeProvider: ActiveConnectorType;
    /**
     * The contents of the schema encoded into a string
     * @remarks only used for the purpose of data proxy
     */
    inlineSchema: string;
    /**
     * A special env object just for the data proxy edge runtime.
     * Allows bundlers to inject their own env variables (Vercel).
     * Allows platforms to declare global variables as env (Workers).
     * @remarks only used for the purpose of data proxy
     */
    injectableEdgeEnv?: () => LoadedEnv;
    /**
     * The contents of the datasource url saved in a string.
     * This can either be an env var name or connection string.
     * It is needed by the client to connect to the Data Proxy.
     * @remarks only used for the purpose of data proxy
     */
    inlineDatasources: {
        [name in string]: {
            url: EnvValue;
        };
    };
    /**
     * The string hash that was produced for a given schema
     * @remarks only used for the purpose of data proxy
     */
    inlineSchemaHash: string;
    /**
     * A marker to indicate that the client was not generated via `prisma
     * generate` but was generated via `generate --postinstall` script instead.
     * @remarks used to error for Vercel/Netlify for schema caching issues
     */
    postinstall?: boolean;
    /**
     * Information about the CI where the Prisma Client has been generated. The
     * name of the CI environment is stored at generation time because CI
     * information is not always available at runtime. Moreover, the edge client
     * has no notion of environment variables, so this works around that.
     * @remarks used to error for Vercel/Netlify for schema caching issues
     */
    ciName?: string;
    /**
     * Information about whether we have not found a schema.prisma file in the
     * default location, and that we fell back to finding the schema.prisma file
     * in the current working directory. This usually means it has been bundled.
     */
    isBundled?: boolean;
    /**
     * A boolean that is `false` when the client was generated with --no-engine. At
     * runtime, this means the client will be bound to be using the Data Proxy.
     */
    copyEngine?: boolean;
    /**
     * Optional wasm loading configuration
     */
    engineWasm?: EngineWasmLoadingConfig;
    compilerWasm?: CompilerWasmLoadingConfig;
};

export declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {
    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;
    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;
    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;
    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;
    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];
    create: GetFindResult<Payload, Args, GlobalOmitOptions>;
    createMany: GetBatchResult;
    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];
    update: GetFindResult<Payload, Args, GlobalOmitOptions>;
    updateMany: GetBatchResult;
    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];
    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;
    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;
    deleteMany: GetBatchResult;
    aggregate: GetAggregateResult<Payload, Args>;
    count: GetCountResult<Args>;
    groupBy: GetGroupByResult<Payload, Args>;
    $queryRaw: unknown;
    $queryRawTyped: unknown;
    $executeRaw: number;
    $queryRawUnsafe: unknown;
    $executeRawUnsafe: number;
    $runCommandRaw: JsonObject;
    findRaw: JsonObject;
    aggregateRaw: JsonObject;
}[OperationName];

export declare function getRuntime(): GetRuntimeOutput;

declare type GetRuntimeOutput = {
    id: RuntimeName;
    prettyName: string;
    isEdge: boolean;
};

export declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {
    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];
};

declare type GlobalOmitOptions = {
    [modelName: string]: {
        [fieldName: string]: boolean;
    };
};

declare type HandleErrorParams = {
    args: JsArgs;
    error: any;
    clientMethod: string;
    callsite?: CallSite;
    transaction?: PrismaPromiseTransaction;
    modelName?: string;
    globalOmit?: GlobalOmitOptions;
};

declare type HrTime = [number, number];

/**
 * Defines High-Resolution Time.
 *
 * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.
 * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.
 * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.
 * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:
 * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.
 * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:
 * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.
 * This is represented in HrTime format as [1609504210, 150000000].
 */
declare type HrTime_2 = [number, number];

declare type Index = ReadonlyDeep_2<{
    model: string;
    type: IndexType;
    isDefinedOnField: boolean;
    name?: string;
    dbName?: string;
    algorithm?: string;
    clustered?: boolean;
    fields: IndexField[];
}>;

declare type IndexField = ReadonlyDeep_2<{
    name: string;
    sortOrder?: SortOrder;
    length?: number;
    operatorClass?: string;
}>;

declare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';

declare type InMemoryOps = {
    pagination: Pagination | null;
    distinct: string[] | null;
    reverse: boolean;
    linkingFields: string[] | null;
    nested: Record<string, InMemoryOps>;
};

/**
 * Matches a JSON array.
 * Unlike \`JsonArray\`, readonly arrays are assignable to this type.
 */
export declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {
}

/**
 * Matches a JSON object.
 * Unlike \`JsonObject\`, this type allows undefined and read-only properties.
 */
export declare type InputJsonObject = {
    readonly [Key in string]?: InputJsonValue | null;
};

/**
 * Matches any valid value that can be used as an input for operations like
 * create and update as the value of a JSON field. Unlike \`JsonValue\`, this
 * type allows read-only arrays and read-only object properties and disallows
 * \`null\` at the top level.
 *
 * \`null\` cannot be used as the value of a JSON field because its meaning
 * would be ambiguous. Use \`Prisma.JsonNull\` to store the JSON null value or
 * \`Prisma.DbNull\` to clear the JSON value and set the field to the database
 * NULL value instead.
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
 */
export declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {
    toJSON(): unknown;
};

declare type InputType = ReadonlyDeep_2<{
    name: string;
    constraints: {
        maxNumFields: number | null;
        minNumFields: number | null;
        fields?: string[];
    };
    meta?: {
        source?: string;
        grouping?: string;
    };
    fields: SchemaArg[];
}>;

declare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;

declare type InteractiveTransactionInfo<Payload = unknown> = {
    /**
     * Transaction ID returned by the query engine.
     */
    id: string;
    /**
     * Arbitrary payload the meaning of which depends on the `Engine` implementation.
     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.
     * In `LibraryEngine` and `BinaryEngine` it is currently not used.
     */
    payload: Payload;
};

declare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;

export declare type InternalArgs<R = {
    [K in string]: {
        [K in string]: unknown;
    };
}, M = {
    [K in string]: {
        [K in string]: unknown;
    };
}, Q = {
    [K in string]: {
        [K in string]: unknown;
    };
}, C = {
    [K in string]: unknown;
}> = {
    result: {
        [K in keyof R]: {
            [P in keyof R[K]]: () => R[K][P];
        };
    };
    model: {
        [K in keyof M]: {
            [P in keyof M[K]]: () => M[K][P];
        };
    };
    query: {
        [K in keyof Q]: {
            [P in keyof Q[K]]: () => Q[K][P];
        };
    };
    client: {
        [K in keyof C]: () => C[K];
    };
};

declare type InternalRequestParams = {
    /**
     * The original client method being called.
     * Even though the rootField / operation can be changed,
     * this method stays as it is, as it's what the user's
     * code looks like
     */
    clientMethod: string;
    /**
     * Name of js model that triggered the request. Might be used
     * for warnings or error messages
     */
    jsModelName?: string;
    callsite?: CallSite;
    transaction?: PrismaPromiseTransaction;
    unpacker?: Unpacker;
    otelParentCtx?: Context;
    /** Used to "desugar" a user input into an "expanded" one */
    argsMapper?: (args?: UserArgs_2) => UserArgs_2;
    /** Used to convert args for middleware and back */
    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;
    /** Used for Accelerate client extension via Data Proxy */
    customDataProxyFetch?: AccelerateExtensionFetchDecorator;
} & Omit<QueryMiddlewareParams, 'runInTransaction'>;

declare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';

declare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';

declare function isSkip(value: unknown): value is Skip;

export declare function isTypedSql(value: unknown): value is UnknownTypedSql;

export declare type ITXClientDenyList = (typeof denylist)[number];

export declare const itxClientDenyList: readonly (string | symbol)[];

declare interface Job {
    resolve: (data: any) => void;
    reject: (data: any) => void;
    request: any;
}

/**
 * Create a SQL query for a list of values.
 */
export declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;

declare type JoinExpression = {
    child: QueryPlanNode;
    on: [left: string, right: string][];
    parentField: string;
    isRelationUnique: boolean;
};

export declare type JsArgs = {
    select?: Selection_2;
    include?: Selection_2;
    omit?: Omission;
    [argName: string]: JsInputValue;
};

export declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {
    [key: string]: JsInputValue;
};

declare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {
    [key: string]: JsonArgumentValue;
};

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {
}

export declare type JsonBatchQuery = {
    batch: JsonQuery[];
    transaction?: {
        isolationLevel?: IsolationLevel_2;
    };
};

export declare interface JsonConvertible {
    toJSON(): unknown;
}

declare type JsonFieldSelection = {
    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;
    selection: JsonSelectionSet;
};

declare class JsonNull extends NullTypesEnumValue {
    #private;
}

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.
 */
export declare type JsonObject = {
    [Key in string]?: JsonValue;
};

export declare type JsonQuery = {
    modelName?: string;
    action: JsonQueryAction;
    query: JsonFieldSelection;
};

declare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';

declare type JsonSelectionSet = {
    $scalars?: boolean;
    $composites?: boolean;
} & {
    [fieldName: string]: boolean | JsonFieldSelection;
};

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;

export declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {
    [key: string]: JsOutputValue;
};

export declare type JsPromise<T> = Promise<T> & {};

declare type KnownErrorParams = {
    code: string;
    clientVersion: string;
    meta?: Record<string, unknown>;
    batchRequestIdx?: number;
};

/**
 * A pointer from the current {@link Span} to another span in the same trace or
 * in a different trace.
 * Few examples of Link usage.
 * 1. Batch Processing: A batch of elements may contain elements associated
 *    with one or more traces/spans. Since there can only be one parent
 *    SpanContext, Link is used to keep reference to SpanContext of all
 *    elements in the batch.
 * 2. Public Endpoint: A SpanContext in incoming client request on a public
 *    endpoint is untrusted from service provider perspective. In such case it
 *    is advisable to start a new trace with appropriate sampling decision.
 *    However, it is desirable to associate incoming SpanContext to new trace
 *    initiated on service provider side so two traces (from Client and from
 *    Service Provider) can be correlated.
 */
declare interface Link {
    /** The {@link SpanContext} of a linked span. */
    context: SpanContext;
    /** A set of {@link SpanAttributes} on the link. */
    attributes?: SpanAttributes;
    /** Count of attributes of the link that were dropped due to collection limits */
    droppedAttributesCount?: number;
}

declare type LoadedEnv = {
    message?: string;
    parsed: {
        [x: string]: string;
    };
} | undefined;

declare type LocationInFile = {
    fileName: string;
    lineNumber: number | null;
    columnNumber: number | null;
};

declare type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
};

/**
 * Typings for the events we emit.
 *
 * @remarks
 * If this is updated, our edge runtime shim needs to be updated as well.
 */
declare type LogEmitter = {
    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;
    emit(event: QueryEventType, payload: QueryEvent): boolean;
    emit(event: LogEventType, payload: LogEvent): boolean;
};

declare type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
};

declare type LogEventType = 'info' | 'warn' | 'error';

declare type LogLevel = 'info' | 'query' | 'warn' | 'error';

/**
 * Generates more strict variant of an enum which, unlike regular enum,
 * throws on non-existing property access. This can be useful in following situations:
 * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input
 * - enum values are generated dynamically from DMMF.
 *
 * In that case, if using normal enums and no compile-time typechecking, using non-existing property
 * will result in `undefined` value being used, which will be accepted. Using strict enum
 * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.
 *
 * Note: if you need to check for existence of a value in the enum you can still use either
 * `in` operator or `hasOwnProperty` function.
 *
 * @param definition
 * @returns
 */
export declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;

export declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;

declare type MappedError = {
    kind: 'GenericJs';
    id: number;
} | {
    kind: 'UnsupportedNativeDataType';
    type: string;
} | {
    kind: 'InvalidIsolationLevel';
    level: string;
} | {
    kind: 'LengthMismatch';
    column?: string;
} | {
    kind: 'UniqueConstraintViolation';
    constraint?: {
        fields: string[];
    } | {
        index: string;
    } | {
        foreignKey: {};
    };
} | {
    kind: 'NullConstraintViolation';
    constraint?: {
        fields: string[];
    } | {
        index: string;
    } | {
        foreignKey: {};
    };
} | {
    kind: 'ForeignKeyConstraintViolation';
    constraint?: {
        fields: string[];
    } | {
        index: string;
    } | {
        foreignKey: {};
    };
} | {
    kind: 'DatabaseNotReachable';
    host?: string;
    port?: number;
} | {
    kind: 'DatabaseDoesNotExist';
    db?: string;
} | {
    kind: 'DatabaseAlreadyExists';
    db?: string;
} | {
    kind: 'DatabaseAccessDenied';
    db?: string;
} | {
    kind: 'ConnectionClosed';
} | {
    kind: 'TlsConnectionError';
    reason: string;
} | {
    kind: 'AuthenticationFailed';
    user?: string;
} | {
    kind: 'TransactionWriteConflict';
} | {
    kind: 'TableDoesNotExist';
    table?: string;
} | {
    kind: 'ColumnNotFound';
    column?: string;
} | {
    kind: 'TooManyConnections';
    cause: string;
} | {
    kind: 'ValueOutOfRange';
    cause: string;
} | {
    kind: 'MissingFullTextSearchIndex';
} | {
    kind: 'SocketTimeout';
} | {
    kind: 'InconsistentColumnData';
    cause: string;
} | {
    kind: 'TransactionAlreadyClosed';
    cause: string;
} | {
    kind: 'postgres';
    code: string;
    severity: string;
    message: string;
    detail: string | undefined;
    column: string | undefined;
    hint: string | undefined;
} | {
    kind: 'mysql';
    code: number;
    message: string;
    state: string;
} | {
    kind: 'sqlite';
    /**
     * Sqlite extended error code: https://www.sqlite.org/rescode.html
     */
    extendedCode: number;
    message: string;
} | {
    kind: 'mssql';
    code: number;
    message: string;
};

declare type Mappings = ReadonlyDeep_2<{
    modelOperations: ModelMapping[];
    otherOperations: {
        read: string[];
        write: string[];
    };
}>;

/**
 * Class that holds the list of all extensions, applied to particular instance,
 * as well as resolved versions of the components that need to apply on
 * different levels. Main idea of this class: avoid re-resolving as much of the
 * stuff as possible when new extensions are added while also delaying the
 * resolve until the point it is actually needed. For example, computed fields
 * of the model won't be resolved unless the model is actually queried. Neither
 * adding extensions with `client` component only cause other components to
 * recompute.
 */
declare class MergedExtensionsList {
    private head?;
    private constructor();
    static empty(): MergedExtensionsList;
    static single(extension: ExtensionArgs): MergedExtensionsList;
    isEmpty(): boolean;
    append(extension: ExtensionArgs): MergedExtensionsList;
    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;
    getAllClientExtensions(): ClientArg | undefined;
    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;
    getAllQueryCallbacks(jsModelName: string, operation: string): any;
    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];
}

export declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;

export declare type Metric<T> = {
    key: string;
    value: T;
    labels: Record<string, string>;
    description: string;
};

export declare type MetricHistogram = {
    buckets: MetricHistogramBucket[];
    sum: number;
    count: number;
};

export declare type MetricHistogramBucket = [maxValue: number, count: number];

export declare type Metrics = {
    counters: Metric<number>[];
    gauges: Metric<number>[];
    histograms: Metric<MetricHistogram>[];
};

export declare class MetricsClient {
    private _client;
    constructor(client: Client);
    /**
     * Returns all metrics gathered up to this point in prometheus format.
     * Result of this call can be exposed directly to prometheus scraping endpoint
     *
     * @param options
     * @returns
     */
    prometheus(options?: MetricsOptions): Promise<string>;
    /**
     * Returns all metrics gathered up to this point in prometheus format.
     *
     * @param options
     * @returns
     */
    json(options?: MetricsOptions): Promise<Metrics>;
}

declare type MetricsOptions = {
    /**
     * Labels to add to every metrics in key-value format
     */
    globalLabels?: Record<string, string>;
};

declare type MetricsOptionsCommon = {
    globalLabels?: Record<string, string>;
};

declare type MetricsOptionsJson = {
    format: 'json';
} & MetricsOptionsCommon;

declare type MetricsOptionsPrometheus = {
    format: 'prometheus';
} & MetricsOptionsCommon;

declare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {
    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;
    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;
};

declare type Model = ReadonlyDeep_2<{
    name: string;
    dbName: string | null;
    schema: string | null;
    fields: Field[];
    uniqueFields: string[][];
    uniqueIndexes: uniqueIndex[];
    documentation?: string;
    primaryKey: PrimaryKey | null;
    isGenerated?: boolean;
}>;

declare enum ModelAction {
    findUnique = "findUnique",
    findUniqueOrThrow = "findUniqueOrThrow",
    findFirst = "findFirst",
    findFirstOrThrow = "findFirstOrThrow",
    findMany = "findMany",
    create = "create",
    createMany = "createMany",
    createManyAndReturn = "createManyAndReturn",
    update = "update",
    updateMany = "updateMany",
    updateManyAndReturn = "updateManyAndReturn",
    upsert = "upsert",
    delete = "delete",
    deleteMany = "deleteMany",
    groupBy = "groupBy",
    count = "count",// TODO: count does not actually exist in DMMF
    aggregate = "aggregate",
    findRaw = "findRaw",
    aggregateRaw = "aggregateRaw"
}

export declare type ModelArg = {
    [MethodName in string]: unknown;
};

export declare type ModelArgs = {
    model: {
        [ModelName in string]: ModelArg;
    };
};

export declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;

declare type ModelMapping = ReadonlyDeep_2<{
    model: string;
    plural: string;
    findUnique?: string | null;
    findUniqueOrThrow?: string | null;
    findFirst?: string | null;
    findFirstOrThrow?: string | null;
    findMany?: string | null;
    create?: string | null;
    createMany?: string | null;
    createManyAndReturn?: string | null;
    update?: string | null;
    updateMany?: string | null;
    updateManyAndReturn?: string | null;
    upsert?: string | null;
    delete?: string | null;
    deleteMany?: string | null;
    aggregate?: string | null;
    groupBy?: string | null;
    count?: string | null;
    findRaw?: string | null;
    aggregateRaw?: string | null;
}>;

export declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;

export declare type ModelQueryOptionsCbArgs = {
    model: string;
    operation: string;
    args: JsArgs;
    query: (args: JsArgs) => Promise<unknown>;
};

declare type MultiBatchResponse = {
    type: 'multi';
    plans: QueryPlanNode[];
};

export declare type NameArgs = {
    name?: string;
};

export declare type Narrow<A> = {
    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;
} | (A extends Narrowable ? A : never);

export declare type Narrowable = string | number | bigint | boolean | [];

export declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;

declare class NullTypesEnumValue extends ObjectEnumValue {
    _getNamespace(): string;
}

/**
 * Base class for unique values of object-valued enums.
 */
export declare abstract class ObjectEnumValue {
    constructor(arg?: symbol);
    abstract _getNamespace(): string;
    _getName(): string;
    toString(): string;
}

export declare const objectEnumValues: {
    classes: {
        DbNull: typeof DbNull;
        JsonNull: typeof JsonNull;
        AnyNull: typeof AnyNull;
    };
    instances: {
        DbNull: DbNull;
        JsonNull: JsonNull;
        AnyNull: AnyNull;
    };
};

declare const officialPrismaAdapters: readonly ["@prisma/adapter-planetscale", "@prisma/adapter-neon", "@prisma/adapter-libsql", "@prisma/adapter-better-sqlite3", "@prisma/adapter-d1", "@prisma/adapter-pg", "@prisma/adapter-mssql", "@prisma/adapter-mariadb"];

export declare type Omission = Record<string, boolean | Skip>;

declare type Omit_2<T, K extends string | number | symbol> = {
    [P in keyof T as P extends K ? never : P]: T[P];
};
export { Omit_2 as Omit }

export declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;

export declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';

export declare type OperationPayload = {
    name: string;
    scalars: {
        [ScalarName in string]: unknown;
    };
    objects: {
        [ObjectName in string]: unknown;
    };
    composites: {
        [CompositeName in string]: unknown;
    };
};

export declare type Optional<O, K extends keyof any = keyof O> = {
    [P in K & keyof O]?: O[P];
} & {
    [P in Exclude<keyof O, K>]: O[P];
};

export declare type OptionalFlat<T> = {
    [K in keyof T]?: T[K];
};

export declare type OptionalKeys<O> = {
    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;
}[keyof O];

declare type Options = {
    /** Timeout for starting the transaction */
    maxWait?: number;
    /** Timeout for the transaction body */
    timeout?: number;
    /** Transaction isolation level */
    isolationLevel?: IsolationLevel_2;
};

declare type Options_2 = {
    clientVersion: string;
};

export declare type Or<A extends 1 | 0, B extends 1 | 0> = {
    0: {
        0: 0;
        1: 1;
    };
    1: {
        0: 1;
        1: 1;
    };
}[A][B];

declare type OtherOperationMappings = ReadonlyDeep_2<{
    read: string[];
    write: string[];
}>;

declare type OutputType = ReadonlyDeep_2<{
    name: string;
    fields: SchemaField[];
}>;

declare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;

declare type Pagination = {
    cursor: Record<string, PrismaValue> | null;
    take: number | null;
    skip: number | null;
};

export declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;

export declare type Param<out $Type, $Value extends string> = {
    readonly name: $Value;
};

export declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;

export declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;

export declare type Payload<T, F extends Operation = never> = T extends {
    [K: symbol]: {
        types: {
            payload: any;
        };
    };
} ? T[symbol]['types']['payload'] : any;

export declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {
    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];
};

declare type Pick_2<T, K extends string | number | symbol> = {
    [P in keyof T as P extends K ? P : never]: T[P];
};
export { Pick_2 as Pick }

declare interface PlaceholderFormat {
    prefix: string;
    hasNumbering: boolean;
}

declare type PrimaryKey = ReadonlyDeep_2<{
    name: string | null;
    fields: string[];
}>;

export declare class PrismaClientInitializationError extends Error {
    clientVersion: string;
    errorCode?: string;
    retryable?: boolean;
    constructor(message: string, clientVersion: string, errorCode?: string);
    get [Symbol.toStringTag](): string;
}

export declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {
    code: string;
    meta?: Record<string, unknown>;
    clientVersion: string;
    batchRequestIdx?: number;
    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);
    get [Symbol.toStringTag](): string;
}

export declare type PrismaClientOptions = {
    /**
     * Overwrites the primary datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.
     */
    adapter?: SqlDriverAdapterFactory | null;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * The default values for Transaction options
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: Transaction_2.Options;
    /**
     * @example
     * \`\`\`
     * // Defaults to stdout
     * log: ['query', 'info', 'warn']
     *
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     * ]
     * \`\`\`
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>;
    omit?: GlobalOmitOptions;
    /**
     * @internal
     * You probably don't want to use this. \`__internal\` is used by internal tooling.
     */
    __internal?: {
        debug?: boolean;
        engine?: {
            cwd?: string;
            binaryPath?: string;
            endpoint?: string;
            allowTriggerPanic?: boolean;
        };
        /** This can be used for testing purposes */
        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;
    };
};

export declare class PrismaClientRustPanicError extends Error {
    clientVersion: string;
    constructor(message: string, clientVersion: string);
    get [Symbol.toStringTag](): string;
}

export declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {
    clientVersion: string;
    batchRequestIdx?: number;
    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);
    get [Symbol.toStringTag](): string;
}

export declare class PrismaClientValidationError extends Error {
    name: string;
    clientVersion: string;
    constructor(message: string, { clientVersion }: Options_2);
    get [Symbol.toStringTag](): string;
}

declare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;

declare type PrismaOperationSpec<TArgs, TAction = string> = {
    args: TArgs;
    action: TAction;
    model: string;
};

export declare interface PrismaPromise<T> extends Promise<T> {
    [Symbol.toStringTag]: 'PrismaPromise';
}

/**
 * Prisma's `Promise` that is backwards-compatible. All additions on top of the
 * original `Promise` are optional so that it can be backwards-compatible.
 * @see [[createPrismaPromise]]
 */
declare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {
    get spec(): TSpec;
    /**
     * Extension of the original `.then` function
     * @param onfulfilled same as regular promises
     * @param onrejected same as regular promises
     * @param transaction transaction options
     */
    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;
    /**
     * Extension of the original `.catch` function
     * @param onrejected same as regular promises
     * @param transaction transaction options
     */
    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;
    /**
     * Extension of the original `.finally` function
     * @param onfinally same as regular promises
     * @param transaction transaction options
     */
    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;
    /**
     * Called when executing a batch of regular tx
     * @param transaction transaction options for batch tx
     */
    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;
}

declare type PrismaPromiseBatchTransaction = {
    kind: 'batch';
    id: number;
    isolationLevel?: IsolationLevel_2;
    index: number;
    lock: PromiseLike<void>;
};

declare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;

/**
 * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which
 * is essentially a proxy for `Promise`. All the transaction-compatible client
 * methods return one, this allows for pre-preparing queries without executing
 * them until `.then` is called. It's the foundation of Prisma's query batching.
 * @param callback that will be wrapped within our promise implementation
 * @see [[PrismaPromise]]
 * @returns
 */
declare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;

declare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {
    kind: 'itx';
    id: string;
    payload: PayloadType;
};

declare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;

declare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;

declare type PrismaValueGenerator = {
    prisma__type: 'generatorCall';
    prisma__value: {
        name: string;
        args: PrismaValue[];
    };
};

declare type PrismaValuePlaceholder = {
    prisma__type: 'param';
    prisma__value: {
        name: string;
        type: string;
    };
};

export declare const PrivateResultType: unique symbol;

declare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';

declare namespace Public {
    export {
        validator
    }
}
export { Public }

declare namespace Public_2 {
    export {
        Args,
        Result,
        Payload,
        PrismaPromise,
        Operation,
        Exact
    }
}

declare type Query = ReadonlyDeep_2<{
    name: string;
    args: SchemaArg[];
    output: QueryOutput;
}>;

declare interface Queryable<Query, Result> extends AdapterInfo {
    /**
     * Execute a query and return its result.
     */
    queryRaw(params: Query): Promise<Result>;
    /**
     * Execute a query and return the number of affected rows.
     */
    executeRaw(params: Query): Promise<number>;
}

declare type QueryCompiler = {
    compile(request: string): {};
    compileBatch(batchRequest: string): BatchResponse;
    free(): void;
};

declare interface QueryCompilerConstructor {
    new (options: QueryCompilerOptions): QueryCompiler;
}

declare type QueryCompilerOptions = {
    datamodel: string;
    provider: Provider;
    connectionInfo: ConnectionInfo;
};

declare type QueryEngineBatchGraphQLRequest = {
    batch: QueryEngineRequest[];
    transaction?: boolean;
    isolationLevel?: IsolationLevel_2;
};

declare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;

declare type QueryEngineConfig = {
    datamodel: string;
    configDir: string;
    logQueries: boolean;
    ignoreEnvVarErrors: boolean;
    datasourceOverrides: Record<string, string>;
    env: Record<string, string | undefined>;
    logLevel: QueryEngineLogLevel;
    engineProtocol: QueryEngineProtocol;
    enableTracing: boolean;
};

declare interface QueryEngineConstructor {
    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;
}

declare type QueryEngineInstance = {
    connect(headers: string, requestId: string): Promise<void>;
    disconnect(headers: string, requestId: string): Promise<void>;
    /**
     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.
     * Noop for other engines.
     */
    free?(): void;
    /**
     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`
     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`
     */
    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;
    sdlSchema?(): Promise<string>;
    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;
    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;
    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;
    metrics?(options: string): Promise<string>;
    applyPendingMigrations?(): Promise<void>;
    trace(requestId: string): Promise<string | null>;
};

declare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';

declare type QueryEngineProtocol = 'graphql' | 'json';

declare type QueryEngineRequest = {
    query: string;
    variables: Object;
};

declare type QueryEngineResultData<T> = {
    data: T;
};

declare type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
};

declare type QueryEventType = 'query';

declare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';

declare type QueryMiddlewareParams = {
    /** The model this is executed on */
    model?: string;
    /** The action that is being handled */
    action: Action;
    /** TODO what is this */
    dataPath: string[];
    /** TODO what is this */
    runInTransaction: boolean;
    args?: UserArgs_2;
};

export declare type QueryOptions = {
    query: {
        [ModelName in string]: {
            [ModelAction in string]: ModelQueryOptionsCb;
        } | QueryOptionsCb;
    };
};

export declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;

export declare type QueryOptionsCbArgs = {
    model?: string;
    operation: string;
    args: JsArgs | RawQueryArgs;
    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;
};

declare type QueryOutput = ReadonlyDeep_2<{
    name: string;
    isRequired: boolean;
    isList: boolean;
}>;

declare type QueryPlanBinding = {
    name: string;
    expr: QueryPlanNode;
};

declare type QueryPlanDbQuery = {
    type: 'rawSql';
    sql: string;
    args: PrismaValue[];
    argTypes: ArgType[];
} | {
    type: 'templateSql';
    fragments: Fragment[];
    placeholderFormat: PlaceholderFormat;
    args: PrismaValue[];
    argTypes: DynamicArgType[];
    chunkable: boolean;
};

declare type QueryPlanNode = {
    type: 'value';
    args: PrismaValue;
} | {
    type: 'seq';
    args: QueryPlanNode[];
} | {
    type: 'get';
    args: {
        name: string;
    };
} | {
    type: 'let';
    args: {
        bindings: QueryPlanBinding[];
        expr: QueryPlanNode;
    };
} | {
    type: 'getFirstNonEmpty';
    args: {
        names: string[];
    };
} | {
    type: 'query';
    args: QueryPlanDbQuery;
} | {
    type: 'execute';
    args: QueryPlanDbQuery;
} | {
    type: 'reverse';
    args: QueryPlanNode;
} | {
    type: 'sum';
    args: QueryPlanNode[];
} | {
    type: 'concat';
    args: QueryPlanNode[];
} | {
    type: 'unique';
    args: QueryPlanNode;
} | {
    type: 'required';
    args: QueryPlanNode;
} | {
    type: 'join';
    args: {
        parent: QueryPlanNode;
        children: JoinExpression[];
    };
} | {
    type: 'mapField';
    args: {
        field: string;
        records: QueryPlanNode;
    };
} | {
    type: 'transaction';
    args: QueryPlanNode;
} | {
    type: 'dataMap';
    args: {
        expr: QueryPlanNode;
        structure: ResultNode;
        enums: Record<string, Record<string, string>>;
    };
} | {
    type: 'validate';
    args: {
        expr: QueryPlanNode;
        rules: DataRule[];
    } & ValidationError;
} | {
    type: 'if';
    args: {
        value: QueryPlanNode;
        rule: DataRule;
        then: QueryPlanNode;
        else: QueryPlanNode;
    };
} | {
    type: 'unit';
} | {
    type: 'diff';
    args: {
        from: QueryPlanNode;
        to: QueryPlanNode;
    };
} | {
    type: 'initializeRecord';
    args: {
        expr: QueryPlanNode;
        fields: Record<string, FieldInitializer>;
    };
} | {
    type: 'mapRecord';
    args: {
        expr: QueryPlanNode;
        fields: Record<string, FieldOperation>;
    };
} | {
    type: 'process';
    args: {
        expr: QueryPlanNode;
        operations: InMemoryOps;
    };
};

/**
 * Create raw SQL statement.
 */
export declare function raw(value: string): Sql;

export declare type RawParameters = {
    __prismaRawParameters__: true;
    values: string;
};

export declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];

declare type RawResponse = {
    columns: string[];
    types: QueryIntrospectionBuiltinType[];
    rows: unknown[][];
};

declare type RawTaggedValue = {
    $type: 'Raw';
    value: unknown;
};

/**
 * Supported value or SQL instance.
 */
export declare type RawValue = Value | Sql;

export declare type ReadonlyDeep<T> = {
    readonly [K in keyof T]: ReadonlyDeep<T[K]>;
};

declare type ReadonlyDeep_2<O> = {
    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;
};

declare type Record_2<T extends string | number | symbol, U> = {
    [P in T]: U;
};
export { Record_2 as Record }

export declare type RenameAndNestPayloadKeys<P> = {
    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];
};

declare type RequestBatchOptions<InteractiveTransactionPayload> = {
    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;
    traceparent?: string;
    numTry?: number;
    containsWrite: boolean;
    customDataProxyFetch?: AccelerateExtensionFetchDecorator;
};

declare interface RequestError {
    error: string;
    user_facing_error: {
        is_panic: boolean;
        message: string;
        meta?: Record<string, unknown>;
        error_code?: string;
        batch_request_idx?: number;
    };
}

declare class RequestHandler {
    client: Client;
    dataloader: DataLoader<RequestParams>;
    private logEmitter?;
    constructor(client: Client, logEmitter?: LogEmitter);
    request(params: RequestParams): Promise<any>;
    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;
    /**
     * Handles the error and logs it, logging the error is done synchronously waiting for the event
     * handlers to finish.
     */
    handleAndLogRequestError(params: HandleErrorParams): never;
    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;
    sanitizeMessage(message: any): any;
    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;
    get [Symbol.toStringTag](): string;
}

declare type RequestOptions<InteractiveTransactionPayload> = {
    traceparent?: string;
    numTry?: number;
    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;
    isWrite: boolean;
    customDataProxyFetch?: AccelerateExtensionFetchDecorator;
};

declare type RequestParams = {
    modelName?: string;
    action: Action;
    protocolQuery: JsonQuery;
    dataPath: string[];
    clientMethod: string;
    callsite?: CallSite;
    transaction?: PrismaPromiseTransaction;
    extensions: MergedExtensionsList;
    args?: any;
    headers?: Record<string, string>;
    unpacker?: Unpacker;
    otelParentCtx?: Context;
    otelChildCtx?: Context;
    globalOmit?: GlobalOmitOptions;
    customDataProxyFetch?: AccelerateExtensionFetchDecorator;
};

declare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;
export { RequiredExtensionArgs }
export { RequiredExtensionArgs as UserArgs }

export declare type RequiredKeys<O> = {
    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;
}[keyof O];

declare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {
    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];
    overrideDatasources: Datasources;
    env: Record<string, string | undefined>;
    clientVersion: string;
}): string;

export declare type Result<T, A, F extends Operation> = T extends {
    [K: symbol]: {
        types: {
            payload: any;
        };
    };
} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{
    composites: {};
    objects: {};
    scalars: {};
    name: '';
}, {}, F>;

export declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;

declare namespace Result_3 {
    export {
        Count,
        GetFindResult,
        SelectablePayloadFields,
        SelectField,
        DefaultSelection,
        UnwrapPayload,
        ApplyOmit,
        OmitValue,
        GetCountResult,
        Aggregate,
        GetAggregateResult,
        GetBatchResult,
        GetGroupByResult,
        GetResult,
        ExtractGlobalOmit
    }
}

declare type Result_4<T> = {
    map<U>(fn: (value: T) => U): Result_4<U>;
    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;
} & ({
    readonly ok: true;
    readonly value: T;
} | {
    readonly ok: false;
    readonly error: Error_2;
});

export declare type ResultArg = {
    [FieldName in string]: ResultFieldDefinition;
};

export declare type ResultArgs = {
    result: {
        [ModelName in string]: ResultArg;
    };
};

export declare type ResultArgsFieldCompute = (model: any) => unknown;

export declare type ResultFieldDefinition = {
    needs?: {
        [FieldName in string]: boolean;
    };
    compute: ResultArgsFieldCompute;
};

declare type ResultNode = {
    type: 'affectedRows';
} | {
    type: 'object';
    fields: Record<string, ResultNode>;
    serializedName: string | null;
    skipNulls: boolean;
} | {
    type: 'field';
    dbName: string;
    fieldType: FieldType;
};

export declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;

export declare type RuntimeDataModel = {
    readonly models: Record<string, RuntimeModel>;
    readonly enums: Record<string, RuntimeEnum>;
    readonly types: Record<string, RuntimeModel>;
};

declare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;

declare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;

declare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';

declare type Schema = ReadonlyDeep_2<{
    rootQueryType?: string;
    rootMutationType?: string;
    inputObjectTypes: {
        model?: InputType[];
        prisma?: InputType[];
    };
    outputObjectTypes: {
        model: OutputType[];
        prisma: OutputType[];
    };
    enumTypes: {
        model?: SchemaEnum[];
        prisma: SchemaEnum[];
    };
    fieldRefTypes: {
        prisma?: FieldRefType[];
    };
}>;

declare type SchemaArg = ReadonlyDeep_2<{
    name: string;
    comment?: string;
    isNullable: boolean;
    isRequired: boolean;
    inputTypes: InputTypeRef[];
    requiresOtherFields?: string[];
    deprecation?: Deprecation;
}>;

declare type SchemaEnum = ReadonlyDeep_2<{
    name: string;
    values: string[];
}>;

declare type SchemaField = ReadonlyDeep_2<{
    name: string;
    isNullable?: boolean;
    outputType: OutputTypeRef;
    args: SchemaArg[];
    deprecation?: Deprecation;
    documentation?: string;
}>;

export declare type Select<T, U> = T extends U ? T : never;

export declare type SelectablePayloadFields<K extends PropertyKey, O> = {
    objects: {
        [k in K]: O;
    };
} | {
    composites: {
        [k in K]: O;
    };
};

export declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {
    objects: Record<K, any>;
} ? P['objects'][K] : P extends {
    composites: Record<K, any>;
} ? P['composites'][K] : never;

declare type Selection_2 = Record<string, boolean | Skip | JsArgs>;
export { Selection_2 as Selection }

export declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;

declare type SerializeParams = {
    runtimeDataModel: RuntimeDataModel;
    modelName?: string;
    action: Action;
    args?: JsArgs;
    extensions?: MergedExtensionsList;
    callsite?: CallSite;
    clientMethod: string;
    clientVersion: string;
    errorFormat: ErrorFormat;
    previewFeatures: string[];
    globalOmit?: GlobalOmitOptions;
};

declare class Skip {
    constructor(param?: symbol);
    ifUndefined<T>(value: T | undefined): T | Skip;
}

export declare const skip: Skip;

declare type SortOrder = 'asc' | 'desc';

/**
 * An interface that represents a span. A span represents a single operation
 * within a trace. Examples of span might include remote procedure calls or a
 * in-process function calls to sub-components. A Trace has a single, top-level
 * "root" Span that in turn may have zero or more child Spans, which in turn
 * may have children.
 *
 * Spans are created by the {@link Tracer.startSpan} method.
 */
declare interface Span {
    /**
     * Returns the {@link SpanContext} object associated with this Span.
     *
     * Get an immutable, serializable identifier for this span that can be used
     * to create new child spans. Returned SpanContext is usable even after the
     * span ends.
     *
     * @returns the SpanContext object associated with this Span.
     */
    spanContext(): SpanContext;
    /**
     * Sets an attribute to the span.
     *
     * Sets a single Attribute with the key and value passed as arguments.
     *
     * @param key the key for this attribute.
     * @param value the value for this attribute. Setting a value null or
     *              undefined is invalid and will result in undefined behavior.
     */
    setAttribute(key: string, value: SpanAttributeValue): this;
    /**
     * Sets attributes to the span.
     *
     * @param attributes the attributes that will be added.
     *                   null or undefined attribute values
     *                   are invalid and will result in undefined behavior.
     */
    setAttributes(attributes: SpanAttributes): this;
    /**
     * Adds an event to the Span.
     *
     * @param name the name of the event.
     * @param [attributesOrStartTime] the attributes that will be added; these are
     *     associated with this event. Can be also a start time
     *     if type is {@type TimeInput} and 3rd param is undefined
     * @param [startTime] start time of the event.
     */
    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;
    /**
     * Adds a single link to the span.
     *
     * Links added after the creation will not affect the sampling decision.
     * It is preferred span links be added at span creation.
     *
     * @param link the link to add.
     */
    addLink(link: Link): this;
    /**
     * Adds multiple links to the span.
     *
     * Links added after the creation will not affect the sampling decision.
     * It is preferred span links be added at span creation.
     *
     * @param links the links to add.
     */
    addLinks(links: Link[]): this;
    /**
     * Sets a status to the span. If used, this will override the default Span
     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value
     * of previous calls to SetStatus on the Span.
     *
     * @param status the SpanStatus to set.
     */
    setStatus(status: SpanStatus): this;
    /**
     * Updates the Span name.
     *
     * This will override the name provided via {@link Tracer.startSpan}.
     *
     * Upon this update, any sampling behavior based on Span name will depend on
     * the implementation.
     *
     * @param name the Span name.
     */
    updateName(name: string): this;
    /**
     * Marks the end of Span execution.
     *
     * Call to End of a Span MUST not have any effects on child spans. Those may
     * still be running and can be ended later.
     *
     * Do not return `this`. The Span generally should not be used after it
     * is ended so chaining is not desired in this context.
     *
     * @param [endTime] the time to set as Span's end time. If not provided,
     *     use the current time as the span's end time.
     */
    end(endTime?: TimeInput): void;
    /**
     * Returns the flag whether this span will be recorded.
     *
     * @returns true if this Span is active and recording information like events
     *     with the `AddEvent` operation and attributes using `setAttributes`.
     */
    isRecording(): boolean;
    /**
     * Sets exception as a span event
     * @param exception the exception the only accepted values are string or Error
     * @param [time] the time to set as Span's event time. If not provided,
     *     use the current time.
     */
    recordException(exception: Exception, time?: TimeInput): void;
}

/**
 * @deprecated please use {@link Attributes}
 */
declare type SpanAttributes = Attributes;

/**
 * @deprecated please use {@link AttributeValue}
 */
declare type SpanAttributeValue = AttributeValue;

declare type SpanCallback<R> = (span?: Span, context?: Context) => R;

/**
 * A SpanContext represents the portion of a {@link Span} which must be
 * serialized and propagated along side of a {@link Baggage}.
 */
declare interface SpanContext {
    /**
     * The ID of the trace that this span belongs to. It is worldwide unique
     * with practically sufficient probability by being made as 16 randomly
     * generated bytes, encoded as a 32 lowercase hex characters corresponding to
     * 128 bits.
     */
    traceId: string;
    /**
     * The ID of the Span. It is globally unique with practically sufficient
     * probability by being made as 8 randomly generated bytes, encoded as a 16
     * lowercase hex characters corresponding to 64 bits.
     */
    spanId: string;
    /**
     * Only true if the SpanContext was propagated from a remote parent.
     */
    isRemote?: boolean;
    /**
     * Trace flags to propagate.
     *
     * It is represented as 1 byte (bitmap). Bit to represent whether trace is
     * sampled or not. When set, the least significant bit documents that the
     * caller may have recorded trace data. A caller who does not record trace
     * data out-of-band leaves this flag unset.
     *
     * see {@link TraceFlags} for valid flag values.
     */
    traceFlags: number;
    /**
     * Tracing-system-specific info to propagate.
     *
     * The tracestate field value is a `list` as defined below. The `list` is a
     * series of `list-members` separated by commas `,`, and a list-member is a
     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
     * surrounding `list-members` are ignored. There can be a maximum of 32
     * `list-members` in a `list`.
     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field
     *
     * Examples:
     *     Single tracing system (generic format):
     *         tracestate: rojo=00f067aa0ba902b7
     *     Multiple tracing systems (with different formatting):
     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE
     */
    traceState?: TraceState;
}

declare enum SpanKind {
    /** Default value. Indicates that the span is used internally. */
    INTERNAL = 0,
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SERVER = 1,
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    CLIENT = 2,
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    PRODUCER = 3,
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    CONSUMER = 4
}

/**
 * Options needed for span creation
 */
declare interface SpanOptions {
    /**
     * The SpanKind of a span
     * @default {@link SpanKind.INTERNAL}
     */
    kind?: SpanKind;
    /** A span's attributes */
    attributes?: SpanAttributes;
    /** {@link Link}s span to other spans */
    links?: Link[];
    /** A manually specified start time for the created `Span` object. */
    startTime?: TimeInput;
    /** The new span should be a root span. (Ignore parent from context). */
    root?: boolean;
}

declare interface SpanStatus {
    /** The status code of this message. */
    code: SpanStatusCode;
    /** A developer-facing error message. */
    message?: string;
}

/**
 * An enumeration of status codes.
 */
declare enum SpanStatusCode {
    /**
     * The default status.
     */
    UNSET = 0,
    /**
     * The operation has been validated by an Application developer or
     * Operator to have completed successfully.
     */
    OK = 1,
    /**
     * The operation contains an error.
     */
    ERROR = 2
}

/**
 * A SQL instance can be nested within each other to build SQL strings.
 */
export declare class Sql {
    readonly values: Value[];
    readonly strings: string[];
    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);
    get sql(): string;
    get statement(): string;
    get text(): string;
    inspect(): {
        sql: string;
        statement: string;
        text: string;
        values: unknown[];
    };
}

declare interface SqlDriverAdapter extends SqlQueryable {
    /**
     * Execute multiple SQL statements separated by semicolon.
     */
    executeScript(script: string): Promise<void>;
    /**
     * Start new transaction.
     */
    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;
    /**
     * Optional method that returns extra connection info
     */
    getConnectionInfo?(): ConnectionInfo;
    /**
     * Dispose of the connection and release any resources.
     */
    dispose(): Promise<void>;
}

export declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {
    connect(): Promise<SqlDriverAdapter>;
}

declare type SqlQuery = {
    sql: string;
    args: Array<unknown>;
    argTypes: Array<ArgType>;
};

declare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {
}

declare interface SqlResultSet {
    /**
     * List of column types appearing in a database query, in the same order as `columnNames`.
     * They are used within the Query Engine to convert values from JS to Quaint values.
     */
    columnTypes: Array<ColumnType>;
    /**
     * List of column names appearing in a database query, in the same order as `columnTypes`.
     */
    columnNames: Array<string>;
    /**
     * List of rows retrieved from a database query.
     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.
     */
    rows: Array<Array<unknown>>;
    /**
     * The last ID of an `INSERT` statement, if any.
     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.
     */
    lastInsertId?: string;
}

/**
 * Create a SQL object from a template string.
 */
export declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;

/**
 * Defines TimeInput.
 *
 * hrtime, epoch milliseconds, performance.now() or Date
 */
declare type TimeInput = HrTime_2 | number | Date;

export declare type ToTuple<T> = T extends any[] ? T : [T];

declare interface TraceState {
    /**
     * Create a new TraceState which inherits from this TraceState and has the
     * given key set.
     * The new entry will always be added in the front of the list of states.
     *
     * @param key key of the TraceState entry.
     * @param value value of the TraceState entry.
     */
    set(key: string, value: string): TraceState;
    /**
     * Return a new TraceState which inherits from this TraceState but does not
     * contain the given key.
     *
     * @param key the key for the TraceState entry to be removed.
     */
    unset(key: string): TraceState;
    /**
     * Returns the value to which the specified key is mapped, or `undefined` if
     * this map contains no mapping for the key.
     *
     * @param key with which the specified value is to be associated.
     * @returns the value to which the specified key is mapped, or `undefined` if
     *     this map contains no mapping for the key.
     */
    get(key: string): string | undefined;
    /**
     * Serializes the TraceState to a `list` as defined below. The `list` is a
     * series of `list-members` separated by commas `,`, and a list-member is a
     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
     * surrounding `list-members` are ignored. There can be a maximum of 32
     * `list-members` in a `list`.
     *
     * @returns the serialized string.
     */
    serialize(): string;
}

declare interface TracingHelper {
    isEnabled(): boolean;
    getTraceParent(context?: Context): string;
    dispatchEngineSpans(spans: EngineSpan[]): void;
    getActiveContext(): Context | undefined;
    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;
}

declare interface Transaction extends AdapterInfo, SqlQueryable {
    /**
     * Transaction options.
     */
    readonly options: TransactionOptions;
    /**
     * Commit the transaction.
     */
    commit(): Promise<void>;
    /**
     * Roll back the transaction.
     */
    rollback(): Promise<void>;
}

declare namespace Transaction_2 {
    export {
        Options,
        IsolationLevel_2 as IsolationLevel,
        InteractiveTransactionInfo,
        TransactionHeaders
    }
}

declare type TransactionHeaders = {
    traceparent?: string;
};

declare type TransactionOptions = {
    usePhantomQuery: boolean;
};

declare type TransactionOptions_2<InteractiveTransactionPayload> = {
    kind: 'itx';
    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;
} | {
    kind: 'batch';
    options: BatchTransactionOptions;
};

export declare class TypedSql<Values extends readonly unknown[], Result> {
    [PrivateResultType]: Result;
    constructor(sql: string, values: Values);
    get sql(): string;
    get values(): Values;
}

export declare type TypeMapCbDef = Fn<{
    extArgs: InternalArgs;
}, TypeMapDef>;

/** Shared */
export declare type TypeMapDef = Record<any, any>;

declare type TypeRef<AllowedLocations extends FieldLocation> = {
    isList: boolean;
    type: string;
    location: AllowedLocations;
    namespace?: FieldNamespace;
};

declare namespace Types {
    export {
        Result_3 as Result,
        Extensions_2 as Extensions,
        Utils,
        Public_2 as Public,
        isSkip,
        Skip,
        skip,
        UnknownTypedSql,
        OperationPayload as Payload
    }
}
export { Types }

declare type uniqueIndex = ReadonlyDeep_2<{
    name: string;
    fields: string[];
}>;

declare type UnknownErrorParams = {
    clientVersion: string;
    batchRequestIdx?: number;
};

export declare type UnknownTypedSql = TypedSql<unknown[], unknown>;

declare type Unpacker = (data: any) => any;

export declare type UnwrapPayload<P> = {} extends P ? unknown : {
    [K in keyof P]: P[K] extends {
        scalars: infer S;
        composites: infer C;
    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {
        scalars: infer S;
        composites: infer C;
    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;
};

export declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;

export declare type UnwrapTuple<Tuple extends readonly unknown[]> = {
    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;
};

/**
 * Input that flows from the user into the Client.
 */
declare type UserArgs_2 = any;

declare namespace Utils {
    export {
        EmptyToUnknown,
        NeverToUnknown,
        PatchFlat,
        Omit_2 as Omit,
        Pick_2 as Pick,
        ComputeDeep,
        Compute,
        OptionalFlat,
        ReadonlyDeep,
        Narrowable,
        Narrow,
        Exact,
        Cast,
        Record_2 as Record,
        UnwrapPromise,
        UnwrapTuple,
        Path,
        Fn,
        Call,
        RequiredKeys,
        OptionalKeys,
        Optional,
        Return,
        ToTuple,
        RenameAndNestPayloadKeys,
        PayloadToResult,
        Select,
        Equals,
        Or,
        JsPromise
    }
}

declare type ValidationError = {
    error_identifier: 'RELATION_VIOLATION';
    context: {
        relation: string;
        modelA: string;
        modelB: string;
    };
} | {
    error_identifier: 'MISSING_RELATED_RECORD';
    context: {
        model: string;
        relation: string;
        relationType: string;
        operation: string;
        neededFor?: string;
    };
} | {
    error_identifier: 'MISSING_RECORD';
    context: {
        operation: string;
    };
} | {
    error_identifier: 'INCOMPLETE_CONNECT_INPUT';
    context: {
        expectedRows: number;
    };
} | {
    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';
    context: {
        expectedRows: number;
        relation: string;
        relationType: string;
    };
} | {
    error_identifier: 'RECORDS_NOT_CONNECTED';
    context: {
        relation: string;
        parent: string;
        child: string;
    };
};

declare function validator<V>(): <S>(select: Exact<S, V>) => S;

declare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;

declare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;

/**
 * Values supported by SQL engine.
 */
export declare type Value = unknown;

export declare function warnEnvConflicts(envPaths: any): void;

export declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;

export { }

// --- FILE: ./src/generated/prisma/runtime/index-browser.d.ts ---

declare class AnyNull extends NullTypesEnumValue {
    #private;
}

declare type Args<T, F extends Operation> = T extends {
    [K: symbol]: {
        types: {
            operations: {
                [K in F]: {
                    args: any;
                };
            };
        };
    };
} ? T[symbol]['types']['operations'][F]['args'] : any;

declare class DbNull extends NullTypesEnumValue {
    #private;
}

export declare function Decimal(n: Decimal.Value): Decimal;

export declare namespace Decimal {
    export type Constructor = typeof Decimal;
    export type Instance = Decimal;
    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
    export type Modulo = Rounding | 9;
    export type Value = string | number | Decimal;

    // http://mikemcl.github.io/decimal.js/#constructor-properties
    export interface Config {
        precision?: number;
        rounding?: Rounding;
        toExpNeg?: number;
        toExpPos?: number;
        minE?: number;
        maxE?: number;
        crypto?: boolean;
        modulo?: Modulo;
        defaults?: boolean;
    }
}

export declare class Decimal {
    readonly d: number[];
    readonly e: number;
    readonly s: number;

    constructor(n: Decimal.Value);

    absoluteValue(): Decimal;
    abs(): Decimal;

    ceil(): Decimal;

    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;
    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;

    comparedTo(n: Decimal.Value): number;
    cmp(n: Decimal.Value): number;

    cosine(): Decimal;
    cos(): Decimal;

    cubeRoot(): Decimal;
    cbrt(): Decimal;

    decimalPlaces(): number;
    dp(): number;

    dividedBy(n: Decimal.Value): Decimal;
    div(n: Decimal.Value): Decimal;

    dividedToIntegerBy(n: Decimal.Value): Decimal;
    divToInt(n: Decimal.Value): Decimal;

    equals(n: Decimal.Value): boolean;
    eq(n: Decimal.Value): boolean;

    floor(): Decimal;

    greaterThan(n: Decimal.Value): boolean;
    gt(n: Decimal.Value): boolean;

    greaterThanOrEqualTo(n: Decimal.Value): boolean;
    gte(n: Decimal.Value): boolean;

    hyperbolicCosine(): Decimal;
    cosh(): Decimal;

    hyperbolicSine(): Decimal;
    sinh(): Decimal;

    hyperbolicTangent(): Decimal;
    tanh(): Decimal;

    inverseCosine(): Decimal;
    acos(): Decimal;

    inverseHyperbolicCosine(): Decimal;
    acosh(): Decimal;

    inverseHyperbolicSine(): Decimal;
    asinh(): Decimal;

    inverseHyperbolicTangent(): Decimal;
    atanh(): Decimal;

    inverseSine(): Decimal;
    asin(): Decimal;

    inverseTangent(): Decimal;
    atan(): Decimal;

    isFinite(): boolean;

    isInteger(): boolean;
    isInt(): boolean;

    isNaN(): boolean;

    isNegative(): boolean;
    isNeg(): boolean;

    isPositive(): boolean;
    isPos(): boolean;

    isZero(): boolean;

    lessThan(n: Decimal.Value): boolean;
    lt(n: Decimal.Value): boolean;

    lessThanOrEqualTo(n: Decimal.Value): boolean;
    lte(n: Decimal.Value): boolean;

    logarithm(n?: Decimal.Value): Decimal;
    log(n?: Decimal.Value): Decimal;

    minus(n: Decimal.Value): Decimal;
    sub(n: Decimal.Value): Decimal;

    modulo(n: Decimal.Value): Decimal;
    mod(n: Decimal.Value): Decimal;

    naturalExponential(): Decimal;
    exp(): Decimal;

    naturalLogarithm(): Decimal;
    ln(): Decimal;

    negated(): Decimal;
    neg(): Decimal;

    plus(n: Decimal.Value): Decimal;
    add(n: Decimal.Value): Decimal;

    precision(includeZeros?: boolean): number;
    sd(includeZeros?: boolean): number;

    round(): Decimal;

    sine() : Decimal;
    sin() : Decimal;

    squareRoot(): Decimal;
    sqrt(): Decimal;

    tangent() : Decimal;
    tan() : Decimal;

    times(n: Decimal.Value): Decimal;
    mul(n: Decimal.Value) : Decimal;

    toBinary(significantDigits?: number): string;
    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;

    toDecimalPlaces(decimalPlaces?: number): Decimal;
    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;
    toDP(decimalPlaces?: number): Decimal;
    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;

    toExponential(decimalPlaces?: number): string;
    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;

    toFixed(decimalPlaces?: number): string;
    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;

    toFraction(max_denominator?: Decimal.Value): Decimal[];

    toHexadecimal(significantDigits?: number): string;
    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;
    toHex(significantDigits?: number): string;
    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;

    toJSON(): string;

    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;

    toNumber(): number;

    toOctal(significantDigits?: number): string;
    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;

    toPower(n: Decimal.Value): Decimal;
    pow(n: Decimal.Value): Decimal;

    toPrecision(significantDigits?: number): string;
    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;

    toSignificantDigits(significantDigits?: number): Decimal;
    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;
    toSD(significantDigits?: number): Decimal;
    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;

    toString(): string;

    truncated(): Decimal;
    trunc(): Decimal;

    valueOf(): string;

    static abs(n: Decimal.Value): Decimal;
    static acos(n: Decimal.Value): Decimal;
    static acosh(n: Decimal.Value): Decimal;
    static add(x: Decimal.Value, y: Decimal.Value): Decimal;
    static asin(n: Decimal.Value): Decimal;
    static asinh(n: Decimal.Value): Decimal;
    static atan(n: Decimal.Value): Decimal;
    static atanh(n: Decimal.Value): Decimal;
    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;
    static cbrt(n: Decimal.Value): Decimal;
    static ceil(n: Decimal.Value): Decimal;
    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;
    static clone(object?: Decimal.Config): Decimal.Constructor;
    static config(object: Decimal.Config): Decimal.Constructor;
    static cos(n: Decimal.Value): Decimal;
    static cosh(n: Decimal.Value): Decimal;
    static div(x: Decimal.Value, y: Decimal.Value): Decimal;
    static exp(n: Decimal.Value): Decimal;
    static floor(n: Decimal.Value): Decimal;
    static hypot(...n: Decimal.Value[]): Decimal;
    static isDecimal(object: any): object is Decimal;
    static ln(n: Decimal.Value): Decimal;
    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;
    static log2(n: Decimal.Value): Decimal;
    static log10(n: Decimal.Value): Decimal;
    static max(...n: Decimal.Value[]): Decimal;
    static min(...n: Decimal.Value[]): Decimal;
    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;
    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;
    static noConflict(): Decimal.Constructor;   // Browser only
    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;
    static random(significantDigits?: number): Decimal;
    static round(n: Decimal.Value): Decimal;
    static set(object: Decimal.Config): Decimal.Constructor;
    static sign(n: Decimal.Value): number;
    static sin(n: Decimal.Value): Decimal;
    static sinh(n: Decimal.Value): Decimal;
    static sqrt(n: Decimal.Value): Decimal;
    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;
    static sum(...n: Decimal.Value[]): Decimal;
    static tan(n: Decimal.Value): Decimal;
    static tanh(n: Decimal.Value): Decimal;
    static trunc(n: Decimal.Value): Decimal;

    static readonly default?: Decimal.Constructor;
    static readonly Decimal?: Decimal.Constructor;

    static readonly precision: number;
    static readonly rounding: Decimal.Rounding;
    static readonly toExpNeg: number;
    static readonly toExpPos: number;
    static readonly minE: number;
    static readonly maxE: number;
    static readonly crypto: boolean;
    static readonly modulo: Decimal.Modulo;

    static readonly ROUND_UP: 0;
    static readonly ROUND_DOWN: 1;
    static readonly ROUND_CEIL: 2;
    static readonly ROUND_FLOOR: 3;
    static readonly ROUND_HALF_UP: 4;
    static readonly ROUND_HALF_DOWN: 5;
    static readonly ROUND_HALF_EVEN: 6;
    static readonly ROUND_HALF_CEIL: 7;
    static readonly ROUND_HALF_FLOOR: 8;
    static readonly EUCLID: 9;
}

declare type Exact<A, W> = (A extends unknown ? (W extends A ? {
    [K in keyof A]: Exact<A[K], W[K]>;
} : W) : never) | (A extends Narrowable ? A : never);

export declare function getRuntime(): GetRuntimeOutput;

declare type GetRuntimeOutput = {
    id: RuntimeName;
    prettyName: string;
    isEdge: boolean;
};

declare class JsonNull extends NullTypesEnumValue {
    #private;
}

/**
 * Generates more strict variant of an enum which, unlike regular enum,
 * throws on non-existing property access. This can be useful in following situations:
 * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input
 * - enum values are generated dynamically from DMMF.
 *
 * In that case, if using normal enums and no compile-time typechecking, using non-existing property
 * will result in `undefined` value being used, which will be accepted. Using strict enum
 * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.
 *
 * Note: if you need to check for existence of a value in the enum you can still use either
 * `in` operator or `hasOwnProperty` function.
 *
 * @param definition
 * @returns
 */
export declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;

declare type Narrowable = string | number | bigint | boolean | [];

declare class NullTypesEnumValue extends ObjectEnumValue {
    _getNamespace(): string;
}

/**
 * Base class for unique values of object-valued enums.
 */
declare abstract class ObjectEnumValue {
    constructor(arg?: symbol);
    abstract _getNamespace(): string;
    _getName(): string;
    toString(): string;
}

export declare const objectEnumValues: {
    classes: {
        DbNull: typeof DbNull;
        JsonNull: typeof JsonNull;
        AnyNull: typeof AnyNull;
    };
    instances: {
        DbNull: DbNull;
        JsonNull: JsonNull;
        AnyNull: AnyNull;
    };
};

declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';

declare namespace Public {
    export {
        validator
    }
}
export { Public }

declare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';

declare function validator<V>(): <S>(select: Exact<S, V>) => S;

declare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;

declare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;

export { }

// --- FILE: ./src/generated/prisma/index.d.ts ---


/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model StartupFailure
 * 
 */
export type StartupFailure = $Result.DefaultSelection<Prisma.$StartupFailurePayload>
/**
 * Model SearchFrontier
 * 
 */
export type SearchFrontier = $Result.DefaultSelection<Prisma.$SearchFrontierPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Status: {
  pending: 'pending',
  completed: 'completed',
  failed: 'failed'
};

export type Status = (typeof Status)[keyof typeof Status]

}

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more StartupFailures
 * const startupFailures = await prisma.startupFailure.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more StartupFailures
   * const startupFailures = await prisma.startupFailure.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.startupFailure`: Exposes CRUD operations for the **StartupFailure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StartupFailures
    * const startupFailures = await prisma.startupFailure.findMany()
    * ```
    */
  get startupFailure(): Prisma.StartupFailureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchFrontier`: Exposes CRUD operations for the **SearchFrontier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchFrontiers
    * const searchFrontiers = await prisma.searchFrontier.findMany()
    * ```
    */
  get searchFrontier(): Prisma.SearchFrontierDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    StartupFailure: 'StartupFailure',
    SearchFrontier: 'SearchFrontier'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "startupFailure" | "searchFrontier"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      StartupFailure: {
        payload: Prisma.$StartupFailurePayload<ExtArgs>
        fields: Prisma.StartupFailureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StartupFailureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupFailurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StartupFailureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupFailurePayload>
          }
          findFirst: {
            args: Prisma.StartupFailureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupFailurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StartupFailureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupFailurePayload>
          }
          findMany: {
            args: Prisma.StartupFailureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupFailurePayload>[]
          }
          create: {
            args: Prisma.StartupFailureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupFailurePayload>
          }
          createMany: {
            args: Prisma.StartupFailureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StartupFailureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupFailurePayload>
          }
          update: {
            args: Prisma.StartupFailureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupFailurePayload>
          }
          deleteMany: {
            args: Prisma.StartupFailureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StartupFailureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StartupFailureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupFailurePayload>
          }
          aggregate: {
            args: Prisma.StartupFailureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStartupFailure>
          }
          groupBy: {
            args: Prisma.StartupFailureGroupByArgs<ExtArgs>
            result: $Utils.Optional<StartupFailureGroupByOutputType>[]
          }
          count: {
            args: Prisma.StartupFailureCountArgs<ExtArgs>
            result: $Utils.Optional<StartupFailureCountAggregateOutputType> | number
          }
        }
      }
      SearchFrontier: {
        payload: Prisma.$SearchFrontierPayload<ExtArgs>
        fields: Prisma.SearchFrontierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchFrontierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchFrontierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchFrontierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchFrontierPayload>
          }
          findFirst: {
            args: Prisma.SearchFrontierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchFrontierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchFrontierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchFrontierPayload>
          }
          findMany: {
            args: Prisma.SearchFrontierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchFrontierPayload>[]
          }
          create: {
            args: Prisma.SearchFrontierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchFrontierPayload>
          }
          createMany: {
            args: Prisma.SearchFrontierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SearchFrontierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchFrontierPayload>
          }
          update: {
            args: Prisma.SearchFrontierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchFrontierPayload>
          }
          deleteMany: {
            args: Prisma.SearchFrontierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchFrontierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchFrontierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchFrontierPayload>
          }
          aggregate: {
            args: Prisma.SearchFrontierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchFrontier>
          }
          groupBy: {
            args: Prisma.SearchFrontierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchFrontierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchFrontierCountArgs<ExtArgs>
            result: $Utils.Optional<SearchFrontierCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    startupFailure?: StartupFailureOmit
    searchFrontier?: SearchFrontierOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model StartupFailure
   */

  export type AggregateStartupFailure = {
    _count: StartupFailureCountAggregateOutputType | null
    _avg: StartupFailureAvgAggregateOutputType | null
    _sum: StartupFailureSumAggregateOutputType | null
    _min: StartupFailureMinAggregateOutputType | null
    _max: StartupFailureMaxAggregateOutputType | null
  }

  export type StartupFailureAvgAggregateOutputType = {
    id: number | null
  }

  export type StartupFailureSumAggregateOutputType = {
    id: number | null
  }

  export type StartupFailureMinAggregateOutputType = {
    id: number | null
    companyName: string | null
    failureReason: string | null
    summary: string | null
    whatTheyDid: string | null
    whatWentWrong: string | null
    keyTakeaway: string | null
    sourceUrl: string | null
  }

  export type StartupFailureMaxAggregateOutputType = {
    id: number | null
    companyName: string | null
    failureReason: string | null
    summary: string | null
    whatTheyDid: string | null
    whatWentWrong: string | null
    keyTakeaway: string | null
    sourceUrl: string | null
  }

  export type StartupFailureCountAggregateOutputType = {
    id: number
    companyName: number
    failureReason: number
    summary: number
    whatTheyDid: number
    whatWentWrong: number
    keyTakeaway: number
    sourceUrl: number
    summary_vector: number
    _all: number
  }


  export type StartupFailureAvgAggregateInputType = {
    id?: true
  }

  export type StartupFailureSumAggregateInputType = {
    id?: true
  }

  export type StartupFailureMinAggregateInputType = {
    id?: true
    companyName?: true
    failureReason?: true
    summary?: true
    whatTheyDid?: true
    whatWentWrong?: true
    keyTakeaway?: true
    sourceUrl?: true
  }

  export type StartupFailureMaxAggregateInputType = {
    id?: true
    companyName?: true
    failureReason?: true
    summary?: true
    whatTheyDid?: true
    whatWentWrong?: true
    keyTakeaway?: true
    sourceUrl?: true
  }

  export type StartupFailureCountAggregateInputType = {
    id?: true
    companyName?: true
    failureReason?: true
    summary?: true
    whatTheyDid?: true
    whatWentWrong?: true
    keyTakeaway?: true
    sourceUrl?: true
    summary_vector?: true
    _all?: true
  }

  export type StartupFailureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StartupFailure to aggregate.
     */
    where?: StartupFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StartupFailures to fetch.
     */
    orderBy?: StartupFailureOrderByWithRelationInput | StartupFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StartupFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StartupFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StartupFailures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StartupFailures
    **/
    _count?: true | StartupFailureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StartupFailureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StartupFailureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StartupFailureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StartupFailureMaxAggregateInputType
  }

  export type GetStartupFailureAggregateType<T extends StartupFailureAggregateArgs> = {
        [P in keyof T & keyof AggregateStartupFailure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStartupFailure[P]>
      : GetScalarType<T[P], AggregateStartupFailure[P]>
  }




  export type StartupFailureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StartupFailureWhereInput
    orderBy?: StartupFailureOrderByWithAggregationInput | StartupFailureOrderByWithAggregationInput[]
    by: StartupFailureScalarFieldEnum[] | StartupFailureScalarFieldEnum
    having?: StartupFailureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StartupFailureCountAggregateInputType | true
    _avg?: StartupFailureAvgAggregateInputType
    _sum?: StartupFailureSumAggregateInputType
    _min?: StartupFailureMinAggregateInputType
    _max?: StartupFailureMaxAggregateInputType
  }

  export type StartupFailureGroupByOutputType = {
    id: number
    companyName: string
    failureReason: string | null
    summary: string | null
    whatTheyDid: string | null
    whatWentWrong: string | null
    keyTakeaway: string | null
    sourceUrl: string | null
    summary_vector: JsonValue | null
    _count: StartupFailureCountAggregateOutputType | null
    _avg: StartupFailureAvgAggregateOutputType | null
    _sum: StartupFailureSumAggregateOutputType | null
    _min: StartupFailureMinAggregateOutputType | null
    _max: StartupFailureMaxAggregateOutputType | null
  }

  type GetStartupFailureGroupByPayload<T extends StartupFailureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StartupFailureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StartupFailureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StartupFailureGroupByOutputType[P]>
            : GetScalarType<T[P], StartupFailureGroupByOutputType[P]>
        }
      >
    >


  export type StartupFailureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    failureReason?: boolean
    summary?: boolean
    whatTheyDid?: boolean
    whatWentWrong?: boolean
    keyTakeaway?: boolean
    sourceUrl?: boolean
    summary_vector?: boolean
  }, ExtArgs["result"]["startupFailure"]>



  export type StartupFailureSelectScalar = {
    id?: boolean
    companyName?: boolean
    failureReason?: boolean
    summary?: boolean
    whatTheyDid?: boolean
    whatWentWrong?: boolean
    keyTakeaway?: boolean
    sourceUrl?: boolean
    summary_vector?: boolean
  }

  export type StartupFailureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "failureReason" | "summary" | "whatTheyDid" | "whatWentWrong" | "keyTakeaway" | "sourceUrl" | "summary_vector", ExtArgs["result"]["startupFailure"]>

  export type $StartupFailurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StartupFailure"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyName: string
      failureReason: string | null
      summary: string | null
      whatTheyDid: string | null
      whatWentWrong: string | null
      keyTakeaway: string | null
      sourceUrl: string | null
      summary_vector: Prisma.JsonValue | null
    }, ExtArgs["result"]["startupFailure"]>
    composites: {}
  }

  type StartupFailureGetPayload<S extends boolean | null | undefined | StartupFailureDefaultArgs> = $Result.GetResult<Prisma.$StartupFailurePayload, S>

  type StartupFailureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StartupFailureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StartupFailureCountAggregateInputType | true
    }

  export interface StartupFailureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StartupFailure'], meta: { name: 'StartupFailure' } }
    /**
     * Find zero or one StartupFailure that matches the filter.
     * @param {StartupFailureFindUniqueArgs} args - Arguments to find a StartupFailure
     * @example
     * // Get one StartupFailure
     * const startupFailure = await prisma.startupFailure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StartupFailureFindUniqueArgs>(args: SelectSubset<T, StartupFailureFindUniqueArgs<ExtArgs>>): Prisma__StartupFailureClient<$Result.GetResult<Prisma.$StartupFailurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StartupFailure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StartupFailureFindUniqueOrThrowArgs} args - Arguments to find a StartupFailure
     * @example
     * // Get one StartupFailure
     * const startupFailure = await prisma.startupFailure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StartupFailureFindUniqueOrThrowArgs>(args: SelectSubset<T, StartupFailureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StartupFailureClient<$Result.GetResult<Prisma.$StartupFailurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StartupFailure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupFailureFindFirstArgs} args - Arguments to find a StartupFailure
     * @example
     * // Get one StartupFailure
     * const startupFailure = await prisma.startupFailure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StartupFailureFindFirstArgs>(args?: SelectSubset<T, StartupFailureFindFirstArgs<ExtArgs>>): Prisma__StartupFailureClient<$Result.GetResult<Prisma.$StartupFailurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StartupFailure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupFailureFindFirstOrThrowArgs} args - Arguments to find a StartupFailure
     * @example
     * // Get one StartupFailure
     * const startupFailure = await prisma.startupFailure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StartupFailureFindFirstOrThrowArgs>(args?: SelectSubset<T, StartupFailureFindFirstOrThrowArgs<ExtArgs>>): Prisma__StartupFailureClient<$Result.GetResult<Prisma.$StartupFailurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StartupFailures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupFailureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StartupFailures
     * const startupFailures = await prisma.startupFailure.findMany()
     * 
     * // Get first 10 StartupFailures
     * const startupFailures = await prisma.startupFailure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const startupFailureWithIdOnly = await prisma.startupFailure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StartupFailureFindManyArgs>(args?: SelectSubset<T, StartupFailureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StartupFailurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StartupFailure.
     * @param {StartupFailureCreateArgs} args - Arguments to create a StartupFailure.
     * @example
     * // Create one StartupFailure
     * const StartupFailure = await prisma.startupFailure.create({
     *   data: {
     *     // ... data to create a StartupFailure
     *   }
     * })
     * 
     */
    create<T extends StartupFailureCreateArgs>(args: SelectSubset<T, StartupFailureCreateArgs<ExtArgs>>): Prisma__StartupFailureClient<$Result.GetResult<Prisma.$StartupFailurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StartupFailures.
     * @param {StartupFailureCreateManyArgs} args - Arguments to create many StartupFailures.
     * @example
     * // Create many StartupFailures
     * const startupFailure = await prisma.startupFailure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StartupFailureCreateManyArgs>(args?: SelectSubset<T, StartupFailureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StartupFailure.
     * @param {StartupFailureDeleteArgs} args - Arguments to delete one StartupFailure.
     * @example
     * // Delete one StartupFailure
     * const StartupFailure = await prisma.startupFailure.delete({
     *   where: {
     *     // ... filter to delete one StartupFailure
     *   }
     * })
     * 
     */
    delete<T extends StartupFailureDeleteArgs>(args: SelectSubset<T, StartupFailureDeleteArgs<ExtArgs>>): Prisma__StartupFailureClient<$Result.GetResult<Prisma.$StartupFailurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StartupFailure.
     * @param {StartupFailureUpdateArgs} args - Arguments to update one StartupFailure.
     * @example
     * // Update one StartupFailure
     * const startupFailure = await prisma.startupFailure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StartupFailureUpdateArgs>(args: SelectSubset<T, StartupFailureUpdateArgs<ExtArgs>>): Prisma__StartupFailureClient<$Result.GetResult<Prisma.$StartupFailurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StartupFailures.
     * @param {StartupFailureDeleteManyArgs} args - Arguments to filter StartupFailures to delete.
     * @example
     * // Delete a few StartupFailures
     * const { count } = await prisma.startupFailure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StartupFailureDeleteManyArgs>(args?: SelectSubset<T, StartupFailureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StartupFailures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupFailureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StartupFailures
     * const startupFailure = await prisma.startupFailure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StartupFailureUpdateManyArgs>(args: SelectSubset<T, StartupFailureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StartupFailure.
     * @param {StartupFailureUpsertArgs} args - Arguments to update or create a StartupFailure.
     * @example
     * // Update or create a StartupFailure
     * const startupFailure = await prisma.startupFailure.upsert({
     *   create: {
     *     // ... data to create a StartupFailure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StartupFailure we want to update
     *   }
     * })
     */
    upsert<T extends StartupFailureUpsertArgs>(args: SelectSubset<T, StartupFailureUpsertArgs<ExtArgs>>): Prisma__StartupFailureClient<$Result.GetResult<Prisma.$StartupFailurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StartupFailures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupFailureCountArgs} args - Arguments to filter StartupFailures to count.
     * @example
     * // Count the number of StartupFailures
     * const count = await prisma.startupFailure.count({
     *   where: {
     *     // ... the filter for the StartupFailures we want to count
     *   }
     * })
    **/
    count<T extends StartupFailureCountArgs>(
      args?: Subset<T, StartupFailureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StartupFailureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StartupFailure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupFailureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StartupFailureAggregateArgs>(args: Subset<T, StartupFailureAggregateArgs>): Prisma.PrismaPromise<GetStartupFailureAggregateType<T>>

    /**
     * Group by StartupFailure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupFailureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StartupFailureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StartupFailureGroupByArgs['orderBy'] }
        : { orderBy?: StartupFailureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StartupFailureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStartupFailureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StartupFailure model
   */
  readonly fields: StartupFailureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StartupFailure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StartupFailureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StartupFailure model
   */
  interface StartupFailureFieldRefs {
    readonly id: FieldRef<"StartupFailure", 'Int'>
    readonly companyName: FieldRef<"StartupFailure", 'String'>
    readonly failureReason: FieldRef<"StartupFailure", 'String'>
    readonly summary: FieldRef<"StartupFailure", 'String'>
    readonly whatTheyDid: FieldRef<"StartupFailure", 'String'>
    readonly whatWentWrong: FieldRef<"StartupFailure", 'String'>
    readonly keyTakeaway: FieldRef<"StartupFailure", 'String'>
    readonly sourceUrl: FieldRef<"StartupFailure", 'String'>
    readonly summary_vector: FieldRef<"StartupFailure", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * StartupFailure findUnique
   */
  export type StartupFailureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StartupFailure
     */
    select?: StartupFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StartupFailure
     */
    omit?: StartupFailureOmit<ExtArgs> | null
    /**
     * Filter, which StartupFailure to fetch.
     */
    where: StartupFailureWhereUniqueInput
  }

  /**
   * StartupFailure findUniqueOrThrow
   */
  export type StartupFailureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StartupFailure
     */
    select?: StartupFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StartupFailure
     */
    omit?: StartupFailureOmit<ExtArgs> | null
    /**
     * Filter, which StartupFailure to fetch.
     */
    where: StartupFailureWhereUniqueInput
  }

  /**
   * StartupFailure findFirst
   */
  export type StartupFailureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StartupFailure
     */
    select?: StartupFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StartupFailure
     */
    omit?: StartupFailureOmit<ExtArgs> | null
    /**
     * Filter, which StartupFailure to fetch.
     */
    where?: StartupFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StartupFailures to fetch.
     */
    orderBy?: StartupFailureOrderByWithRelationInput | StartupFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StartupFailures.
     */
    cursor?: StartupFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StartupFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StartupFailures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StartupFailures.
     */
    distinct?: StartupFailureScalarFieldEnum | StartupFailureScalarFieldEnum[]
  }

  /**
   * StartupFailure findFirstOrThrow
   */
  export type StartupFailureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StartupFailure
     */
    select?: StartupFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StartupFailure
     */
    omit?: StartupFailureOmit<ExtArgs> | null
    /**
     * Filter, which StartupFailure to fetch.
     */
    where?: StartupFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StartupFailures to fetch.
     */
    orderBy?: StartupFailureOrderByWithRelationInput | StartupFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StartupFailures.
     */
    cursor?: StartupFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StartupFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StartupFailures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StartupFailures.
     */
    distinct?: StartupFailureScalarFieldEnum | StartupFailureScalarFieldEnum[]
  }

  /**
   * StartupFailure findMany
   */
  export type StartupFailureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StartupFailure
     */
    select?: StartupFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StartupFailure
     */
    omit?: StartupFailureOmit<ExtArgs> | null
    /**
     * Filter, which StartupFailures to fetch.
     */
    where?: StartupFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StartupFailures to fetch.
     */
    orderBy?: StartupFailureOrderByWithRelationInput | StartupFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StartupFailures.
     */
    cursor?: StartupFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StartupFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StartupFailures.
     */
    skip?: number
    distinct?: StartupFailureScalarFieldEnum | StartupFailureScalarFieldEnum[]
  }

  /**
   * StartupFailure create
   */
  export type StartupFailureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StartupFailure
     */
    select?: StartupFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StartupFailure
     */
    omit?: StartupFailureOmit<ExtArgs> | null
    /**
     * The data needed to create a StartupFailure.
     */
    data: XOR<StartupFailureCreateInput, StartupFailureUncheckedCreateInput>
  }

  /**
   * StartupFailure createMany
   */
  export type StartupFailureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StartupFailures.
     */
    data: StartupFailureCreateManyInput | StartupFailureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StartupFailure update
   */
  export type StartupFailureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StartupFailure
     */
    select?: StartupFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StartupFailure
     */
    omit?: StartupFailureOmit<ExtArgs> | null
    /**
     * The data needed to update a StartupFailure.
     */
    data: XOR<StartupFailureUpdateInput, StartupFailureUncheckedUpdateInput>
    /**
     * Choose, which StartupFailure to update.
     */
    where: StartupFailureWhereUniqueInput
  }

  /**
   * StartupFailure updateMany
   */
  export type StartupFailureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StartupFailures.
     */
    data: XOR<StartupFailureUpdateManyMutationInput, StartupFailureUncheckedUpdateManyInput>
    /**
     * Filter which StartupFailures to update
     */
    where?: StartupFailureWhereInput
    /**
     * Limit how many StartupFailures to update.
     */
    limit?: number
  }

  /**
   * StartupFailure upsert
   */
  export type StartupFailureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StartupFailure
     */
    select?: StartupFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StartupFailure
     */
    omit?: StartupFailureOmit<ExtArgs> | null
    /**
     * The filter to search for the StartupFailure to update in case it exists.
     */
    where: StartupFailureWhereUniqueInput
    /**
     * In case the StartupFailure found by the `where` argument doesn't exist, create a new StartupFailure with this data.
     */
    create: XOR<StartupFailureCreateInput, StartupFailureUncheckedCreateInput>
    /**
     * In case the StartupFailure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StartupFailureUpdateInput, StartupFailureUncheckedUpdateInput>
  }

  /**
   * StartupFailure delete
   */
  export type StartupFailureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StartupFailure
     */
    select?: StartupFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StartupFailure
     */
    omit?: StartupFailureOmit<ExtArgs> | null
    /**
     * Filter which StartupFailure to delete.
     */
    where: StartupFailureWhereUniqueInput
  }

  /**
   * StartupFailure deleteMany
   */
  export type StartupFailureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StartupFailures to delete
     */
    where?: StartupFailureWhereInput
    /**
     * Limit how many StartupFailures to delete.
     */
    limit?: number
  }

  /**
   * StartupFailure without action
   */
  export type StartupFailureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StartupFailure
     */
    select?: StartupFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StartupFailure
     */
    omit?: StartupFailureOmit<ExtArgs> | null
  }


  /**
   * Model SearchFrontier
   */

  export type AggregateSearchFrontier = {
    _count: SearchFrontierCountAggregateOutputType | null
    _avg: SearchFrontierAvgAggregateOutputType | null
    _sum: SearchFrontierSumAggregateOutputType | null
    _min: SearchFrontierMinAggregateOutputType | null
    _max: SearchFrontierMaxAggregateOutputType | null
  }

  export type SearchFrontierAvgAggregateOutputType = {
    id: number | null
  }

  export type SearchFrontierSumAggregateOutputType = {
    id: number | null
  }

  export type SearchFrontierMinAggregateOutputType = {
    id: number | null
    query: string | null
    status: $Enums.Status | null
    createdAt: Date | null
  }

  export type SearchFrontierMaxAggregateOutputType = {
    id: number | null
    query: string | null
    status: $Enums.Status | null
    createdAt: Date | null
  }

  export type SearchFrontierCountAggregateOutputType = {
    id: number
    query: number
    status: number
    createdAt: number
    _all: number
  }


  export type SearchFrontierAvgAggregateInputType = {
    id?: true
  }

  export type SearchFrontierSumAggregateInputType = {
    id?: true
  }

  export type SearchFrontierMinAggregateInputType = {
    id?: true
    query?: true
    status?: true
    createdAt?: true
  }

  export type SearchFrontierMaxAggregateInputType = {
    id?: true
    query?: true
    status?: true
    createdAt?: true
  }

  export type SearchFrontierCountAggregateInputType = {
    id?: true
    query?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type SearchFrontierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchFrontier to aggregate.
     */
    where?: SearchFrontierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchFrontiers to fetch.
     */
    orderBy?: SearchFrontierOrderByWithRelationInput | SearchFrontierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchFrontierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchFrontiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchFrontiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchFrontiers
    **/
    _count?: true | SearchFrontierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchFrontierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchFrontierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchFrontierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchFrontierMaxAggregateInputType
  }

  export type GetSearchFrontierAggregateType<T extends SearchFrontierAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchFrontier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchFrontier[P]>
      : GetScalarType<T[P], AggregateSearchFrontier[P]>
  }




  export type SearchFrontierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchFrontierWhereInput
    orderBy?: SearchFrontierOrderByWithAggregationInput | SearchFrontierOrderByWithAggregationInput[]
    by: SearchFrontierScalarFieldEnum[] | SearchFrontierScalarFieldEnum
    having?: SearchFrontierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchFrontierCountAggregateInputType | true
    _avg?: SearchFrontierAvgAggregateInputType
    _sum?: SearchFrontierSumAggregateInputType
    _min?: SearchFrontierMinAggregateInputType
    _max?: SearchFrontierMaxAggregateInputType
  }

  export type SearchFrontierGroupByOutputType = {
    id: number
    query: string
    status: $Enums.Status
    createdAt: Date
    _count: SearchFrontierCountAggregateOutputType | null
    _avg: SearchFrontierAvgAggregateOutputType | null
    _sum: SearchFrontierSumAggregateOutputType | null
    _min: SearchFrontierMinAggregateOutputType | null
    _max: SearchFrontierMaxAggregateOutputType | null
  }

  type GetSearchFrontierGroupByPayload<T extends SearchFrontierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchFrontierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchFrontierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchFrontierGroupByOutputType[P]>
            : GetScalarType<T[P], SearchFrontierGroupByOutputType[P]>
        }
      >
    >


  export type SearchFrontierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["searchFrontier"]>



  export type SearchFrontierSelectScalar = {
    id?: boolean
    query?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type SearchFrontierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "query" | "status" | "createdAt", ExtArgs["result"]["searchFrontier"]>

  export type $SearchFrontierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchFrontier"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      query: string
      status: $Enums.Status
      createdAt: Date
    }, ExtArgs["result"]["searchFrontier"]>
    composites: {}
  }

  type SearchFrontierGetPayload<S extends boolean | null | undefined | SearchFrontierDefaultArgs> = $Result.GetResult<Prisma.$SearchFrontierPayload, S>

  type SearchFrontierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchFrontierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchFrontierCountAggregateInputType | true
    }

  export interface SearchFrontierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchFrontier'], meta: { name: 'SearchFrontier' } }
    /**
     * Find zero or one SearchFrontier that matches the filter.
     * @param {SearchFrontierFindUniqueArgs} args - Arguments to find a SearchFrontier
     * @example
     * // Get one SearchFrontier
     * const searchFrontier = await prisma.searchFrontier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchFrontierFindUniqueArgs>(args: SelectSubset<T, SearchFrontierFindUniqueArgs<ExtArgs>>): Prisma__SearchFrontierClient<$Result.GetResult<Prisma.$SearchFrontierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchFrontier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchFrontierFindUniqueOrThrowArgs} args - Arguments to find a SearchFrontier
     * @example
     * // Get one SearchFrontier
     * const searchFrontier = await prisma.searchFrontier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchFrontierFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchFrontierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchFrontierClient<$Result.GetResult<Prisma.$SearchFrontierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchFrontier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchFrontierFindFirstArgs} args - Arguments to find a SearchFrontier
     * @example
     * // Get one SearchFrontier
     * const searchFrontier = await prisma.searchFrontier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchFrontierFindFirstArgs>(args?: SelectSubset<T, SearchFrontierFindFirstArgs<ExtArgs>>): Prisma__SearchFrontierClient<$Result.GetResult<Prisma.$SearchFrontierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchFrontier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchFrontierFindFirstOrThrowArgs} args - Arguments to find a SearchFrontier
     * @example
     * // Get one SearchFrontier
     * const searchFrontier = await prisma.searchFrontier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchFrontierFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchFrontierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchFrontierClient<$Result.GetResult<Prisma.$SearchFrontierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchFrontiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchFrontierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchFrontiers
     * const searchFrontiers = await prisma.searchFrontier.findMany()
     * 
     * // Get first 10 SearchFrontiers
     * const searchFrontiers = await prisma.searchFrontier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchFrontierWithIdOnly = await prisma.searchFrontier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchFrontierFindManyArgs>(args?: SelectSubset<T, SearchFrontierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchFrontierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchFrontier.
     * @param {SearchFrontierCreateArgs} args - Arguments to create a SearchFrontier.
     * @example
     * // Create one SearchFrontier
     * const SearchFrontier = await prisma.searchFrontier.create({
     *   data: {
     *     // ... data to create a SearchFrontier
     *   }
     * })
     * 
     */
    create<T extends SearchFrontierCreateArgs>(args: SelectSubset<T, SearchFrontierCreateArgs<ExtArgs>>): Prisma__SearchFrontierClient<$Result.GetResult<Prisma.$SearchFrontierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchFrontiers.
     * @param {SearchFrontierCreateManyArgs} args - Arguments to create many SearchFrontiers.
     * @example
     * // Create many SearchFrontiers
     * const searchFrontier = await prisma.searchFrontier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchFrontierCreateManyArgs>(args?: SelectSubset<T, SearchFrontierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SearchFrontier.
     * @param {SearchFrontierDeleteArgs} args - Arguments to delete one SearchFrontier.
     * @example
     * // Delete one SearchFrontier
     * const SearchFrontier = await prisma.searchFrontier.delete({
     *   where: {
     *     // ... filter to delete one SearchFrontier
     *   }
     * })
     * 
     */
    delete<T extends SearchFrontierDeleteArgs>(args: SelectSubset<T, SearchFrontierDeleteArgs<ExtArgs>>): Prisma__SearchFrontierClient<$Result.GetResult<Prisma.$SearchFrontierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchFrontier.
     * @param {SearchFrontierUpdateArgs} args - Arguments to update one SearchFrontier.
     * @example
     * // Update one SearchFrontier
     * const searchFrontier = await prisma.searchFrontier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchFrontierUpdateArgs>(args: SelectSubset<T, SearchFrontierUpdateArgs<ExtArgs>>): Prisma__SearchFrontierClient<$Result.GetResult<Prisma.$SearchFrontierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchFrontiers.
     * @param {SearchFrontierDeleteManyArgs} args - Arguments to filter SearchFrontiers to delete.
     * @example
     * // Delete a few SearchFrontiers
     * const { count } = await prisma.searchFrontier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchFrontierDeleteManyArgs>(args?: SelectSubset<T, SearchFrontierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchFrontiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchFrontierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchFrontiers
     * const searchFrontier = await prisma.searchFrontier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchFrontierUpdateManyArgs>(args: SelectSubset<T, SearchFrontierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchFrontier.
     * @param {SearchFrontierUpsertArgs} args - Arguments to update or create a SearchFrontier.
     * @example
     * // Update or create a SearchFrontier
     * const searchFrontier = await prisma.searchFrontier.upsert({
     *   create: {
     *     // ... data to create a SearchFrontier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchFrontier we want to update
     *   }
     * })
     */
    upsert<T extends SearchFrontierUpsertArgs>(args: SelectSubset<T, SearchFrontierUpsertArgs<ExtArgs>>): Prisma__SearchFrontierClient<$Result.GetResult<Prisma.$SearchFrontierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchFrontiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchFrontierCountArgs} args - Arguments to filter SearchFrontiers to count.
     * @example
     * // Count the number of SearchFrontiers
     * const count = await prisma.searchFrontier.count({
     *   where: {
     *     // ... the filter for the SearchFrontiers we want to count
     *   }
     * })
    **/
    count<T extends SearchFrontierCountArgs>(
      args?: Subset<T, SearchFrontierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchFrontierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchFrontier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchFrontierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchFrontierAggregateArgs>(args: Subset<T, SearchFrontierAggregateArgs>): Prisma.PrismaPromise<GetSearchFrontierAggregateType<T>>

    /**
     * Group by SearchFrontier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchFrontierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchFrontierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchFrontierGroupByArgs['orderBy'] }
        : { orderBy?: SearchFrontierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchFrontierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchFrontierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchFrontier model
   */
  readonly fields: SearchFrontierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchFrontier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchFrontierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchFrontier model
   */
  interface SearchFrontierFieldRefs {
    readonly id: FieldRef<"SearchFrontier", 'Int'>
    readonly query: FieldRef<"SearchFrontier", 'String'>
    readonly status: FieldRef<"SearchFrontier", 'Status'>
    readonly createdAt: FieldRef<"SearchFrontier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchFrontier findUnique
   */
  export type SearchFrontierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchFrontier
     */
    select?: SearchFrontierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchFrontier
     */
    omit?: SearchFrontierOmit<ExtArgs> | null
    /**
     * Filter, which SearchFrontier to fetch.
     */
    where: SearchFrontierWhereUniqueInput
  }

  /**
   * SearchFrontier findUniqueOrThrow
   */
  export type SearchFrontierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchFrontier
     */
    select?: SearchFrontierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchFrontier
     */
    omit?: SearchFrontierOmit<ExtArgs> | null
    /**
     * Filter, which SearchFrontier to fetch.
     */
    where: SearchFrontierWhereUniqueInput
  }

  /**
   * SearchFrontier findFirst
   */
  export type SearchFrontierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchFrontier
     */
    select?: SearchFrontierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchFrontier
     */
    omit?: SearchFrontierOmit<ExtArgs> | null
    /**
     * Filter, which SearchFrontier to fetch.
     */
    where?: SearchFrontierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchFrontiers to fetch.
     */
    orderBy?: SearchFrontierOrderByWithRelationInput | SearchFrontierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchFrontiers.
     */
    cursor?: SearchFrontierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchFrontiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchFrontiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchFrontiers.
     */
    distinct?: SearchFrontierScalarFieldEnum | SearchFrontierScalarFieldEnum[]
  }

  /**
   * SearchFrontier findFirstOrThrow
   */
  export type SearchFrontierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchFrontier
     */
    select?: SearchFrontierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchFrontier
     */
    omit?: SearchFrontierOmit<ExtArgs> | null
    /**
     * Filter, which SearchFrontier to fetch.
     */
    where?: SearchFrontierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchFrontiers to fetch.
     */
    orderBy?: SearchFrontierOrderByWithRelationInput | SearchFrontierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchFrontiers.
     */
    cursor?: SearchFrontierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchFrontiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchFrontiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchFrontiers.
     */
    distinct?: SearchFrontierScalarFieldEnum | SearchFrontierScalarFieldEnum[]
  }

  /**
   * SearchFrontier findMany
   */
  export type SearchFrontierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchFrontier
     */
    select?: SearchFrontierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchFrontier
     */
    omit?: SearchFrontierOmit<ExtArgs> | null
    /**
     * Filter, which SearchFrontiers to fetch.
     */
    where?: SearchFrontierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchFrontiers to fetch.
     */
    orderBy?: SearchFrontierOrderByWithRelationInput | SearchFrontierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchFrontiers.
     */
    cursor?: SearchFrontierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchFrontiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchFrontiers.
     */
    skip?: number
    distinct?: SearchFrontierScalarFieldEnum | SearchFrontierScalarFieldEnum[]
  }

  /**
   * SearchFrontier create
   */
  export type SearchFrontierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchFrontier
     */
    select?: SearchFrontierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchFrontier
     */
    omit?: SearchFrontierOmit<ExtArgs> | null
    /**
     * The data needed to create a SearchFrontier.
     */
    data: XOR<SearchFrontierCreateInput, SearchFrontierUncheckedCreateInput>
  }

  /**
   * SearchFrontier createMany
   */
  export type SearchFrontierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchFrontiers.
     */
    data: SearchFrontierCreateManyInput | SearchFrontierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchFrontier update
   */
  export type SearchFrontierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchFrontier
     */
    select?: SearchFrontierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchFrontier
     */
    omit?: SearchFrontierOmit<ExtArgs> | null
    /**
     * The data needed to update a SearchFrontier.
     */
    data: XOR<SearchFrontierUpdateInput, SearchFrontierUncheckedUpdateInput>
    /**
     * Choose, which SearchFrontier to update.
     */
    where: SearchFrontierWhereUniqueInput
  }

  /**
   * SearchFrontier updateMany
   */
  export type SearchFrontierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchFrontiers.
     */
    data: XOR<SearchFrontierUpdateManyMutationInput, SearchFrontierUncheckedUpdateManyInput>
    /**
     * Filter which SearchFrontiers to update
     */
    where?: SearchFrontierWhereInput
    /**
     * Limit how many SearchFrontiers to update.
     */
    limit?: number
  }

  /**
   * SearchFrontier upsert
   */
  export type SearchFrontierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchFrontier
     */
    select?: SearchFrontierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchFrontier
     */
    omit?: SearchFrontierOmit<ExtArgs> | null
    /**
     * The filter to search for the SearchFrontier to update in case it exists.
     */
    where: SearchFrontierWhereUniqueInput
    /**
     * In case the SearchFrontier found by the `where` argument doesn't exist, create a new SearchFrontier with this data.
     */
    create: XOR<SearchFrontierCreateInput, SearchFrontierUncheckedCreateInput>
    /**
     * In case the SearchFrontier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchFrontierUpdateInput, SearchFrontierUncheckedUpdateInput>
  }

  /**
   * SearchFrontier delete
   */
  export type SearchFrontierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchFrontier
     */
    select?: SearchFrontierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchFrontier
     */
    omit?: SearchFrontierOmit<ExtArgs> | null
    /**
     * Filter which SearchFrontier to delete.
     */
    where: SearchFrontierWhereUniqueInput
  }

  /**
   * SearchFrontier deleteMany
   */
  export type SearchFrontierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchFrontiers to delete
     */
    where?: SearchFrontierWhereInput
    /**
     * Limit how many SearchFrontiers to delete.
     */
    limit?: number
  }

  /**
   * SearchFrontier without action
   */
  export type SearchFrontierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchFrontier
     */
    select?: SearchFrontierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchFrontier
     */
    omit?: SearchFrontierOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const StartupFailureScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    failureReason: 'failureReason',
    summary: 'summary',
    whatTheyDid: 'whatTheyDid',
    whatWentWrong: 'whatWentWrong',
    keyTakeaway: 'keyTakeaway',
    sourceUrl: 'sourceUrl',
    summary_vector: 'summary_vector'
  };

  export type StartupFailureScalarFieldEnum = (typeof StartupFailureScalarFieldEnum)[keyof typeof StartupFailureScalarFieldEnum]


  export const SearchFrontierScalarFieldEnum: {
    id: 'id',
    query: 'query',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type SearchFrontierScalarFieldEnum = (typeof SearchFrontierScalarFieldEnum)[keyof typeof SearchFrontierScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const StartupFailureOrderByRelevanceFieldEnum: {
    companyName: 'companyName',
    failureReason: 'failureReason',
    summary: 'summary',
    whatTheyDid: 'whatTheyDid',
    whatWentWrong: 'whatWentWrong',
    keyTakeaway: 'keyTakeaway',
    sourceUrl: 'sourceUrl'
  };

  export type StartupFailureOrderByRelevanceFieldEnum = (typeof StartupFailureOrderByRelevanceFieldEnum)[keyof typeof StartupFailureOrderByRelevanceFieldEnum]


  export const SearchFrontierOrderByRelevanceFieldEnum: {
    query: 'query'
  };

  export type SearchFrontierOrderByRelevanceFieldEnum = (typeof SearchFrontierOrderByRelevanceFieldEnum)[keyof typeof SearchFrontierOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type StartupFailureWhereInput = {
    AND?: StartupFailureWhereInput | StartupFailureWhereInput[]
    OR?: StartupFailureWhereInput[]
    NOT?: StartupFailureWhereInput | StartupFailureWhereInput[]
    id?: IntFilter<"StartupFailure"> | number
    companyName?: StringFilter<"StartupFailure"> | string
    failureReason?: StringNullableFilter<"StartupFailure"> | string | null
    summary?: StringNullableFilter<"StartupFailure"> | string | null
    whatTheyDid?: StringNullableFilter<"StartupFailure"> | string | null
    whatWentWrong?: StringNullableFilter<"StartupFailure"> | string | null
    keyTakeaway?: StringNullableFilter<"StartupFailure"> | string | null
    sourceUrl?: StringNullableFilter<"StartupFailure"> | string | null
    summary_vector?: JsonNullableFilter<"StartupFailure">
  }

  export type StartupFailureOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    whatTheyDid?: SortOrderInput | SortOrder
    whatWentWrong?: SortOrderInput | SortOrder
    keyTakeaway?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    summary_vector?: SortOrderInput | SortOrder
    _relevance?: StartupFailureOrderByRelevanceInput
  }

  export type StartupFailureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StartupFailureWhereInput | StartupFailureWhereInput[]
    OR?: StartupFailureWhereInput[]
    NOT?: StartupFailureWhereInput | StartupFailureWhereInput[]
    companyName?: StringFilter<"StartupFailure"> | string
    failureReason?: StringNullableFilter<"StartupFailure"> | string | null
    summary?: StringNullableFilter<"StartupFailure"> | string | null
    whatTheyDid?: StringNullableFilter<"StartupFailure"> | string | null
    whatWentWrong?: StringNullableFilter<"StartupFailure"> | string | null
    keyTakeaway?: StringNullableFilter<"StartupFailure"> | string | null
    sourceUrl?: StringNullableFilter<"StartupFailure"> | string | null
    summary_vector?: JsonNullableFilter<"StartupFailure">
  }, "id">

  export type StartupFailureOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    whatTheyDid?: SortOrderInput | SortOrder
    whatWentWrong?: SortOrderInput | SortOrder
    keyTakeaway?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    summary_vector?: SortOrderInput | SortOrder
    _count?: StartupFailureCountOrderByAggregateInput
    _avg?: StartupFailureAvgOrderByAggregateInput
    _max?: StartupFailureMaxOrderByAggregateInput
    _min?: StartupFailureMinOrderByAggregateInput
    _sum?: StartupFailureSumOrderByAggregateInput
  }

  export type StartupFailureScalarWhereWithAggregatesInput = {
    AND?: StartupFailureScalarWhereWithAggregatesInput | StartupFailureScalarWhereWithAggregatesInput[]
    OR?: StartupFailureScalarWhereWithAggregatesInput[]
    NOT?: StartupFailureScalarWhereWithAggregatesInput | StartupFailureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StartupFailure"> | number
    companyName?: StringWithAggregatesFilter<"StartupFailure"> | string
    failureReason?: StringNullableWithAggregatesFilter<"StartupFailure"> | string | null
    summary?: StringNullableWithAggregatesFilter<"StartupFailure"> | string | null
    whatTheyDid?: StringNullableWithAggregatesFilter<"StartupFailure"> | string | null
    whatWentWrong?: StringNullableWithAggregatesFilter<"StartupFailure"> | string | null
    keyTakeaway?: StringNullableWithAggregatesFilter<"StartupFailure"> | string | null
    sourceUrl?: StringNullableWithAggregatesFilter<"StartupFailure"> | string | null
    summary_vector?: JsonNullableWithAggregatesFilter<"StartupFailure">
  }

  export type SearchFrontierWhereInput = {
    AND?: SearchFrontierWhereInput | SearchFrontierWhereInput[]
    OR?: SearchFrontierWhereInput[]
    NOT?: SearchFrontierWhereInput | SearchFrontierWhereInput[]
    id?: IntFilter<"SearchFrontier"> | number
    query?: StringFilter<"SearchFrontier"> | string
    status?: EnumStatusFilter<"SearchFrontier"> | $Enums.Status
    createdAt?: DateTimeFilter<"SearchFrontier"> | Date | string
  }

  export type SearchFrontierOrderByWithRelationInput = {
    id?: SortOrder
    query?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _relevance?: SearchFrontierOrderByRelevanceInput
  }

  export type SearchFrontierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    query?: string
    AND?: SearchFrontierWhereInput | SearchFrontierWhereInput[]
    OR?: SearchFrontierWhereInput[]
    NOT?: SearchFrontierWhereInput | SearchFrontierWhereInput[]
    status?: EnumStatusFilter<"SearchFrontier"> | $Enums.Status
    createdAt?: DateTimeFilter<"SearchFrontier"> | Date | string
  }, "id" | "query">

  export type SearchFrontierOrderByWithAggregationInput = {
    id?: SortOrder
    query?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: SearchFrontierCountOrderByAggregateInput
    _avg?: SearchFrontierAvgOrderByAggregateInput
    _max?: SearchFrontierMaxOrderByAggregateInput
    _min?: SearchFrontierMinOrderByAggregateInput
    _sum?: SearchFrontierSumOrderByAggregateInput
  }

  export type SearchFrontierScalarWhereWithAggregatesInput = {
    AND?: SearchFrontierScalarWhereWithAggregatesInput | SearchFrontierScalarWhereWithAggregatesInput[]
    OR?: SearchFrontierScalarWhereWithAggregatesInput[]
    NOT?: SearchFrontierScalarWhereWithAggregatesInput | SearchFrontierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SearchFrontier"> | number
    query?: StringWithAggregatesFilter<"SearchFrontier"> | string
    status?: EnumStatusWithAggregatesFilter<"SearchFrontier"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"SearchFrontier"> | Date | string
  }

  export type StartupFailureCreateInput = {
    companyName: string
    failureReason?: string | null
    summary?: string | null
    whatTheyDid?: string | null
    whatWentWrong?: string | null
    keyTakeaway?: string | null
    sourceUrl?: string | null
    summary_vector?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StartupFailureUncheckedCreateInput = {
    id?: number
    companyName: string
    failureReason?: string | null
    summary?: string | null
    whatTheyDid?: string | null
    whatWentWrong?: string | null
    keyTakeaway?: string | null
    sourceUrl?: string | null
    summary_vector?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StartupFailureUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    whatTheyDid?: NullableStringFieldUpdateOperationsInput | string | null
    whatWentWrong?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaway?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary_vector?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StartupFailureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    whatTheyDid?: NullableStringFieldUpdateOperationsInput | string | null
    whatWentWrong?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaway?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary_vector?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StartupFailureCreateManyInput = {
    id?: number
    companyName: string
    failureReason?: string | null
    summary?: string | null
    whatTheyDid?: string | null
    whatWentWrong?: string | null
    keyTakeaway?: string | null
    sourceUrl?: string | null
    summary_vector?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StartupFailureUpdateManyMutationInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    whatTheyDid?: NullableStringFieldUpdateOperationsInput | string | null
    whatWentWrong?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaway?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary_vector?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StartupFailureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    whatTheyDid?: NullableStringFieldUpdateOperationsInput | string | null
    whatWentWrong?: NullableStringFieldUpdateOperationsInput | string | null
    keyTakeaway?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary_vector?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SearchFrontierCreateInput = {
    query: string
    status?: $Enums.Status
    createdAt?: Date | string
  }

  export type SearchFrontierUncheckedCreateInput = {
    id?: number
    query: string
    status?: $Enums.Status
    createdAt?: Date | string
  }

  export type SearchFrontierUpdateInput = {
    query?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchFrontierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    query?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchFrontierCreateManyInput = {
    id?: number
    query: string
    status?: $Enums.Status
    createdAt?: Date | string
  }

  export type SearchFrontierUpdateManyMutationInput = {
    query?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchFrontierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    query?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type StartupFailureOrderByRelevanceInput = {
    fields: StartupFailureOrderByRelevanceFieldEnum | StartupFailureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StartupFailureCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    failureReason?: SortOrder
    summary?: SortOrder
    whatTheyDid?: SortOrder
    whatWentWrong?: SortOrder
    keyTakeaway?: SortOrder
    sourceUrl?: SortOrder
    summary_vector?: SortOrder
  }

  export type StartupFailureAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StartupFailureMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    failureReason?: SortOrder
    summary?: SortOrder
    whatTheyDid?: SortOrder
    whatWentWrong?: SortOrder
    keyTakeaway?: SortOrder
    sourceUrl?: SortOrder
  }

  export type StartupFailureMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    failureReason?: SortOrder
    summary?: SortOrder
    whatTheyDid?: SortOrder
    whatWentWrong?: SortOrder
    keyTakeaway?: SortOrder
    sourceUrl?: SortOrder
  }

  export type StartupFailureSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SearchFrontierOrderByRelevanceInput = {
    fields: SearchFrontierOrderByRelevanceFieldEnum | SearchFrontierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SearchFrontierCountOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchFrontierAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SearchFrontierMaxOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchFrontierMinOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchFrontierSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
// --- FILE: ./src/generated/prisma/default.d.ts ---

export * from "./index"
// --- FILE: ./src/generated/prisma/client.d.ts ---

export * from "./index"
// --- FILE: ./src/app/(pages)/dashboard/layout.tsx ---

"use client";

import React, { useState, useMemo } from "react";
import Link from "next/link";
// import { useSession, signOut } from "next-auth/react"; // Placeholder for auth
import { useTheme } from "next-themes";
import { Button } from "@/components/ui/button";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuLabel, DropdownMenuSeparator, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import {
  ChevronsUpDown, LayoutGrid, BookUser, CreditCard, Settings, LifeBuoy, LogOut,
  HelpCircle, MessageSquare, PanelLeftClose, PanelLeftOpen, Sun, Moon, FolderKanban,
  Loader2, Plus, Trash2, Download,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { DashboardProvider, useDashboard, Session } from "@/components/DashboardContext";
import { ScrollArea } from "@/components/ui/scroll-area";
import Logo from "@/components/Logo";

// A small component to render the layout content, so it can access the context
function DashboardLayoutContent({ children }: { children: React.ReactNode }) {
  const { setTheme } = useTheme();
  const [isCollapsed, setIsCollapsed] = useState(true);
  
  const { sessions, activeSessionId, loadSession, newSession, deleteSession } = useDashboard();

  const handleExport = () => {
    if (Object.keys(sessions).length === 0) {
        alert("No sessions to export.");
        return;
    }
    const dataStr = JSON.stringify(sessions, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'cassandra-sessions.json';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  const sessionGroups = useMemo(() => {
    const groups: { [key: string]: Session[] } = { Today: [], Yesterday: [], "Previous 7 Days": [], "Older": [] };
    const today = new Date(); const yesterday = new Date(today); yesterday.setDate(yesterday.getDate() - 1); const sevenDaysAgo = new Date(today); sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    
    Object.values(sessions)
      .filter(Boolean)
      .sort((a, b) => b.createdAt - a.createdAt)
      .forEach(session => {
        const sessionDate = new Date(session.createdAt);
        if (sessionDate.toDateString() === today.toDateString()) groups.Today.push(session);
        else if (sessionDate.toDateString() === yesterday.toDateString()) groups.Yesterday.push(session);
        else if (sessionDate > sevenDaysAgo) groups["Previous 7 Days"].push(session);
        else groups.Older.push(session);
    });
    return groups;
  }, [sessions]);


  return (
    <TooltipProvider>
      <div className="flex h-screen w-full bg-background text-foreground overflow-hidden">
        <aside className={cn(
          "hidden md:flex flex-col border-r bg-muted/40 transition-all duration-300 ease-in-out",
          isCollapsed ? "w-[56px]" : "w-[240px]"
        )}>
           <div className={cn("flex h-14 items-center border-b px-4")}>
            <Logo hideText={isCollapsed} />
           </div>
           <div className="p-2">
             <Button onClick={newSession} className="w-full" variant="outline" size={isCollapsed ? "icon" : "default"}>
                <Plus className="h-4 w-4" />
                <span className={cn("ml-2", isCollapsed && "hidden")}>New Session</span>
             </Button>
           </div>
           <ScrollArea className="flex-1 px-2">
             {Object.entries(sessionGroups).map(([groupName, groupSessions]) => ( groupSessions.length > 0 && (
                <div key={groupName} className="py-2">
                  <h3 className={cn("text-xs font-semibold text-muted-foreground px-2 mb-2", isCollapsed && "text-center")}>{isCollapsed ? groupName.substring(0,1) : groupName}</h3>
                  <div className="space-y-1">
                    {groupSessions.map(session => (
                      <Tooltip key={session.id} delayDuration={0}>
                        <TooltipTrigger asChild>
                          <div
                            onClick={() => loadSession(session.id)}
                            className={cn(
                              "group flex items-center gap-3 rounded-md px-3 py-2 text-sm cursor-pointer transition-all hover:bg-accent hover:text-accent-foreground",
                              activeSessionId === session.id ? "bg-accent text-accent-foreground" : "text-muted-foreground",
                              isCollapsed && "justify-center"
                            )}
                          >
                            <MessageSquare className="h-4 w-4 shrink-0" />
                            {/* --- MODIFICATION START: Added flex-1 and min-w-0 to fix long title bug --- */}
                            <span className={cn("flex-1 truncate min-w-0", isCollapsed && "hidden")}>
                              {session.name}
                            </span>
                            {/* --- MODIFICATION END --- */}
                             <Button
                                onClick={(e) => { e.stopPropagation(); deleteSession(session.id); }}
                                variant="ghost" size="icon"
                                className={cn("ml-auto h-6 w-6 shrink-0 opacity-0 group-hover:opacity-100", isCollapsed && "hidden")}
                              >
                               <Trash2 className="h-4 w-4 text-red-500" />
                             </Button>
                          </div>
                        </TooltipTrigger>
                        {isCollapsed && (<TooltipContent side="right">{session.name}</TooltipContent>)}
                      </Tooltip>
                    ))}
                  </div>
                </div>
              )))}
           </ScrollArea>
           <div className="mt-auto border-t p-2">
             <Tooltip delayDuration={0}>
               <TooltipTrigger asChild>
                 <Button onClick={() => setIsCollapsed(!isCollapsed)} variant="ghost" className="w-full justify-start gap-3 rounded-md px-3 py-2 text-sm text-muted-foreground transition-all hover:bg-accent hover:text-accent-foreground">
                   {isCollapsed ? <PanelLeftOpen className="h-4 w-4" /> : <PanelLeftClose className="h-4 w-4" />}
                   <span className={cn("truncate", isCollapsed && "hidden")}>Collapse</span>
                 </Button>
               </TooltipTrigger>
               {isCollapsed && (<TooltipContent side="right">Expand</TooltipContent>)}
             </Tooltip>
           </div>
        </aside>

        <div className="flex flex-1 flex-col">
          <header className="flex h-14 items-center gap-4 border-b bg-background px-6 shrink-0">
             <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" className="flex-1 justify-between max-w-xs">
                    <div className="flex items-center gap-2">
                      <div className="p-1 rounded-md bg-zinc-700/50">
                          <FolderKanban className="size-4 text-zinc-300"/>
                      </div>
                      <span className="font-semibold">My Startup Analysis</span>
                    </div>
                    <ChevronsUpDown className="h-4 w-4 text-muted-foreground" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="start" className="w-[var(--radix-dropdown-menu-trigger-width)]">
                  <DropdownMenuLabel>Projects (Coming Soon)</DropdownMenuLabel>
                  <DropdownMenuItem disabled>My Startup Analysis</DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>

            <div className="ml-auto flex items-center gap-2">
            <Tooltip delayDuration={0}>
                  <TooltipTrigger asChild>
                    <Button asChild variant="ghost" size="icon" className="h-8 w-8">
                      <Link href="/browse">
                        <LayoutGrid className="h-4 w-4" />
                        <span className="sr-only">Browse Corpus</span>
                      </Link>
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent side="bottom">Browse Corpus</TooltipContent>
              </Tooltip>
              <DropdownMenu>
                <DropdownMenuTrigger asChild><Button variant="ghost" size="icon" className="h-8 w-8"><Sun className="h-4 w-4 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" /><Moon className="absolute h-4 w-4 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" /><span className="sr-only">Toggle theme</span></Button></DropdownMenuTrigger>
                <DropdownMenuContent align="end"><DropdownMenuItem onClick={() => setTheme("light")}>Light</DropdownMenuItem><DropdownMenuItem onClick={() => setTheme("dark")}>Dark</DropdownMenuItem><DropdownMenuItem onClick={() => setTheme("system")}>System</DropdownMenuItem></DropdownMenuContent>
              </DropdownMenu>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" size="icon" className="rounded-full h-8 w-8">
                    <Avatar className="h-8 w-8">
                      <AvatarImage src={`https://api.dicebear.com/8.x/lorelei/svg?seed=cassandra-user`} alt={'User'} />
                      <AvatarFallback>U</AvatarFallback>
                    </Avatar>
                  </Button>
                </DropdownMenuTrigger>
                 <DropdownMenuContent align="end">
                    <DropdownMenuLabel>Account</DropdownMenuLabel>
                    {/* --- MODIFICATION START: Added Export button with handler --- */}
                    <DropdownMenuItem onClick={handleExport}>
                      <Download className="mr-2 h-4 w-4" />
                      <span>Export Sessions</span>
                    </DropdownMenuItem>
                    {/* --- MODIFICATION END --- */}
                    <DropdownMenuSeparator />
                    <DropdownMenuItem disabled><Settings className="mr-2 h-4 w-4" /><span>Settings</span></DropdownMenuItem>
                    <DropdownMenuItem disabled><LifeBuoy className="mr-2 h-4 w-4" /><span>Support</span></DropdownMenuItem>
                  </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </header>
          <main className="flex-1 bg-muted/20 overflow-hidden relative">
            {children}
          </main>
        </div>
      </div>
    </TooltipProvider>
  )
}

// The main layout component wraps its children in the provider
export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  return (
    <DashboardProvider>
      <DashboardLayoutContent>{children}</DashboardLayoutContent>
    </DashboardProvider>
  );
}
// --- FILE: ./src/app/(pages)/dashboard/page.tsx ---

// --- FILE: src/app/dashboard/page.tsx ---
"use client";

import React, { useCallback, useMemo, useEffect } from 'react';
import {
  ReactFlow,
  Controls,
  Background,
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
  OnConnect,
  ReactFlowProvider,
  MiniMap,
  BackgroundVariant,
  SmoothStepEdge,
  Edge,
  useReactFlow
} from 'reactflow';
import { useTheme } from 'next-themes';
import { motion, AnimatePresence } from 'framer-motion';
import { BrainCircuit } from 'lucide-react';
import { useDashboard, CassandraNode } from '@/components/DashboardContext';
import PitchNode from '@/components/PitchNode';
import { Button } from '@/components/ui/button';

import 'reactflow/dist/style.css';

function CanvasController() {
  const { fitView } = useReactFlow();
  const { nodes, activeSessionId } = useDashboard();

  useEffect(() => {
    const isStreaming = nodes.some(node => node.data.isLoading);
    if (isStreaming) {
      fitView({ duration: 800, padding: 0.2 });
    }
  }, [nodes, fitView]);

  useEffect(() => {
    if (nodes.length > 0) {
      fitView({
        nodes: [{ id: nodes[0].id }],
        duration: 800,
        padding: 0.2,
      });
    }
  }, [activeSessionId]); // Removed `fitView` and `nodes` from deps to only run on session change

  return null;
}


function DashboardCanvas() {
  const { resolvedTheme } = useTheme();
  const { nodes, setNodes, edges, setEdges } = useDashboard();
  const [selectedNodes, setSelectedNodes] = React.useState<CassandraNode[]>([]);
  
  const { fitView } = useReactFlow();

  const onNodesChange = useCallback((changes: any) => setNodes((nds) => applyNodeChanges(changes, nds)), [setNodes]);
  const onEdgesChange = useCallback((changes: any) => setEdges((eds) => applyEdgeChanges(changes, eds)), [setEdges]);
  const onConnect: OnConnect = useCallback((connection) => setEdges((eds) => addEdge(connection, eds)), [setEdges]);
  const onSelectionChange = useCallback(({ nodes }: { nodes: CassandraNode[] }) => { setSelectedNodes(nodes); }, []);

  const nodeTypes = useMemo(() => ({ pitchNode: PitchNode }), []);
  const edgeTypes = useMemo(() => ({ smoothstep: SmoothStepEdge }), []);

  const handleStreamingAnalysis = useCallback(async (nodeId: string, pitch: string, file: File | null) => {
    setNodes(nds => nds.map(n => n.id === nodeId ? { ...n, data: { ...n.data, isLoading: true, response: '', structuredResponse: null } } : n));

    const currentNode = nodes.find(n => n.id === nodeId);
    const parentId = currentNode?.data.parentId;
    const parentNode = parentId ? nodes.find(n => n.id === parentId) : null;

    const formData = new FormData();
    formData.append('pitch', pitch);
    if (file) formData.append('file', file);
    if (parentNode) {
      formData.append('parentPitch', parentNode.data.pitch);
      if (parentNode.data.response) formData.append('parentAnalysis', parentNode.data.response);
    }

    try {
      const response = await fetch('/api/analyze', { method: 'POST', body: formData });
      
      if (!response.ok || !response.body) throw new Error(`API error: ${response.statusText}`);
      
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      let jsonParsed = false;
      const separator = '---';

      const read = async () => {
        const { done, value } = await reader.read();
        if (done) {
          setNodes(nds => nds.map(n => n.id === nodeId ? { ...n, data: { ...n.data, isLoading: false } } : n));
          return;
        }

        buffer += decoder.decode(value, { stream: true });
        
        if (!jsonParsed) {
          const separatorIndex = buffer.indexOf(separator);
          if (separatorIndex !== -1) {
            const jsonString = buffer.substring(0, separatorIndex);
            try {
              const parsedJson = JSON.parse(jsonString);
              setNodes(nds => nds.map(n => n.id === nodeId ? { ...n, data: { ...n.data, structuredResponse: parsedJson } } : n));
              
              const markdownContent = buffer.substring(separatorIndex + separator.length);
              setNodes(nds => nds.map(n => n.id === nodeId ? { ...n, data: { ...n.data, response: markdownContent } } : n));

              jsonParsed = true;
            } catch (e) {
              // Incomplete JSON, continue buffering.
            }
          }
        } else {
          // JSON already parsed, append the rest of the stream as markdown
          setNodes(nds => nds.map(n => n.id === nodeId ? { ...n, data: { ...n.data, response: (n.data.response || '') + buffer } } : n));
          // Reset buffer after appending
          buffer = '';
        }

        // After processing, if jsonParsed, we can append the rest of the current chunk directly
        if(jsonParsed && buffer.length > 0) {
           setNodes(nds => nds.map(n => n.id === nodeId ? { ...n, data: { ...n.data, response: (n.data.response || '') + buffer } } : n));
           buffer = '';
        }
        
        await read();
      };
      await read();
    } catch (error) {
      console.error("Failed to stream analysis:", error);
      const errorMessage = "Sorry, I couldn't complete the analysis. The AI model may be overloaded. Please try again.";
      setNodes(nds => nds.map(n => n.id === nodeId ? { ...n, data: { ...n.data, response: errorMessage, isLoading: false } } : n));
    }
  }, [setNodes, nodes]);

  const createFollowUpNode = useCallback((text: string, sourceId: string) => {
    const sourceNode = nodes.find(n => n.id === sourceId);
    if (!sourceNode) return;
    const { position: sourcePos, data: sourceData, width, height } = sourceNode;
    if (!sourcePos) return;

    const newNodeId = `node_${Date.now()}`;
    const contextTitle = sourceData.pitch && sourceData.pitch.length > 50 ? sourceData.pitch.substring(0, 50) + '...' : sourceData.pitch;
    const newNodeWidth = 500;

    const newNode: CassandraNode = {
      id: newNodeId,
      type: 'pitchNode',
      position: { x: sourcePos.x + (width || newNodeWidth) / 2 - (newNodeWidth / 2), y: sourcePos.y + (height || 200) + 60 },
      data: { 
        pitch: text, 
        response: null, 
        isLoading: false, 
        contextTitle, 
        parentId: sourceId,
        onAnalysis: () => {},
        createFollowUpNode: () => {},
      },
    };
    const newEdge: Edge = {
      id: `e-${sourceId}-${newNodeId}`,
      type: 'smoothstep',
      source: sourceId,
      target: newNodeId,
      style: { stroke: resolvedTheme === 'dark' ? '#444' : '#ccc', strokeWidth: 2 },
    };
    setNodes(n => [...n, newNode]);
    setEdges(e => [...e, newEdge]);
  }, [resolvedTheme, setNodes, setEdges, nodes]);

  const handleMerge = useCallback(async () => {
    if (selectedNodes.length < 2) return;
    const content = selectedNodes.map((n, i) => `--- Entry ${i + 1} ---\nPitch: ${n.data.pitch}\nAnalysis: ${n.data.response || 'N/A'}`).join('\n\n');
    const prompt = `Synthesize these entries:\n\n${content}`;
    const avgX = selectedNodes.reduce((s, n) => s + n.position.x, 0) / selectedNodes.length;
    const avgY = selectedNodes.reduce((s, n) => s + n.position.y, 0) / selectedNodes.length;
    const newId = `n_merged_${Date.now()}`;

    const loadingNode: CassandraNode = { 
      id: newId, 
      type: 'pitchNode', 
      position: { x: avgX, y: avgY }, 
      data: { pitch: 'Merging nodes...', isLoading: true, response: null, onAnalysis: () => {}, createFollowUpNode: () => {} } 
    };
    const selectedIds = new Set(selectedNodes.map(n => n.id));
    setNodes(nds => [...nds.filter(n => !selectedIds.has(n.id)), loadingNode]);
    setEdges(eds => eds.filter(e => !selectedIds.has(e.source) && !selectedIds.has(e.target)));
    setSelectedNodes([]);
    
    // This is a placeholder for a real merge API call
    await new Promise(r => setTimeout(r, 1000));
    const mergedResponse = `This is a synthesized summary of ${selectedNodes.length} previous analyses. The recurring themes identified are market viability and user acquisition challenges. The consensus points towards prioritizing a niche-first strategy to validate the core value proposition before scaling.`;
    setNodes(nds => nds.map(n => n.id === newId ? { ...n, data: { ...n.data, pitch: 'Synthesized Analysis', response: mergedResponse, isLoading: false } } : n));
  }, [selectedNodes, setNodes, setEdges]);

  const nodesWithHandlers = useMemo(() => nodes.map(n => ({ ...n, data: { ...n.data, onAnalysis: handleStreamingAnalysis, createFollowUpNode } })), [nodes, handleStreamingAnalysis, createFollowUpNode]);
  
  if (nodes.length === 0) {
      return (
          <div className="flex flex-col items-center justify-center h-full w-full text-center">
              <BrainCircuit className="h-12 w-12 text-muted-foreground mb-4"/>
              <h2 className="text-xl font-semibold">Welcome to your Canvas</h2>
              <p className="text-muted-foreground">Create a new session to get started.</p>
          </div>
      )
  }

  return (
    <div className="h-full w-full">
      <ReactFlow
        nodes={nodesWithHandlers}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        edgeTypes={edgeTypes}
        defaultEdgeOptions={{ type: 'smoothstep' }}
        className={resolvedTheme || 'dark'}
        onSelectionChange={onSelectionChange}
        multiSelectionKeyCode={null}
        selectionKeyCode="Shift"
        fitView
      >
        <Controls />
        <Background variant={BackgroundVariant.Dots} gap={16} size={0.5} />
        <MiniMap nodeColor={() => '#fbbf24'} nodeStrokeWidth={3} pannable />
        <CanvasController />
      </ReactFlow>
      
       <AnimatePresence>
          {selectedNodes.length > 1 && (
            <motion.div
              className="absolute bottom-10 left-1/2 -translate-x-1/2 z-10"
              initial={{ y: 50, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              exit={{ y: 50, opacity: 0 }}
            >
              <Button onClick={handleMerge} className="shadow-2xl">
                Merge {selectedNodes.length} Nodes
              </Button>
            </motion.div>
          )}
      </AnimatePresence>
    </div>
  );
}

export default function DashboardPage() {
  return (
    <ReactFlowProvider>
      <DashboardCanvas />
    </ReactFlowProvider>
  );
}
// --- FILE: ./src/app/(pages)/browse/_components/search-input.tsx ---

'use client';

import { Input } from '@/components/ui/input';
import { useDebounce } from '@/hooks/use-debounce';
import { Search } from 'lucide-react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useEffect, useState } from 'react';

export function SearchInput({ placeholder }: { placeholder: string }) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const initialQuery = searchParams.get('q') || '';
  
  const [value, setValue] = useState(initialQuery);
  const debouncedValue = useDebounce(value, 500);

  useEffect(() => {
    const current = new URLSearchParams(Array.from(searchParams.entries()));
    
    if (!debouncedValue) {
      current.delete('q');
    } else {
      current.set('q', debouncedValue);
    }
    // Always reset to page 1 when search query changes
    current.set('page', '1');

    const search = current.toString();
    const query = search ? `?${search}` : '';

    router.push(`/browse${query}`);
  }, [debouncedValue, router, searchParams]);

  return (
    <div className="relative">
      <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
      <Input
        value={value}
        onChange={(e) => setValue(e.target.value)}
        placeholder={placeholder}
        className="pl-10"
      />
    </div>
  );
}
// --- FILE: ./src/app/(pages)/browse/layout.tsx ---

// src/app/browse/layout.tsx
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import Logo from '@/components/Logo';

export default function BrowseLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen bg-background text-foreground">
      <nav className="border-b">
        <div className="container mx-auto px-4 h-14 flex items-center justify-between">
          <Logo />
          <Button asChild>
            <Link href="/dashboard">Back to Canvas</Link>
          </Button>
        </div>
      </nav>
      <main>{children}</main>
    </div>
  );
}
// --- FILE: ./src/app/(pages)/browse/page.tsx ---

// src/app/browse/page.tsx
import prisma from '@/lib/prisma';
import Link from 'next/link';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge'; // We'll create this simple component
import { ArrowLeft, ArrowRight, ExternalLink } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { SearchInput } from './_components/search-input'; // We'll create this

const ITEMS_PER_PAGE = 12;

export default async function BrowsePage({
  searchParams,
}: {
  searchParams: { page?: string; q?: string };
}) {
  const page = Number(searchParams.page) || 1;
  const searchQuery = searchParams.q || '';

  const whereClause = searchQuery 
    ? {
        OR: [
          { companyName: { contains: searchQuery, mode: 'insensitive' } },
          { failureReason: { contains: searchQuery, mode: 'insensitive' } },
          { keyTakeaway: { contains: searchQuery, mode: 'insensitive' } },
        ],
      }
    : {};

  const failures = await prisma.startupFailure.findMany({
    where: whereClause,
    take: ITEMS_PER_PAGE,
    skip: (page - 1) * ITEMS_PER_PAGE,
    orderBy: {
      id: 'desc', // Show most recently added first
    },
  });

  const totalCount = await prisma.startupFailure.count({ where: whereClause });
  const totalPages = Math.ceil(totalCount / ITEMS_PER_PAGE);

  return (
    <div className="container mx-auto px-4 py-8">
      <header className="mb-8">
        <h1 className="text-4xl font-bold tracking-tighter">Failure Corpus</h1>
        <p className="text-muted-foreground mt-2">
          An browsable archive of {totalCount} startup post-mortems collected by the Cassandra agent.
        </p>
      </header>

      <div className="mb-6">
        <SearchInput placeholder="Search by company, reason, or takeaway..." />
      </div>

      {failures.length === 0 ? (
        <div className="text-center py-16">
          <p className="text-lg text-muted-foreground">No results found for your query.</p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {failures.map((failure) => (
            <Card key={failure.id} className="flex flex-col">
              <CardHeader>
                <CardTitle className="text-lg">{failure.companyName}</CardTitle>
                {failure.failureReason && (
                    <CardDescription>
                        <Badge variant="secondary">{failure.failureReason}</Badge>
                    </CardDescription>
                )}
              </CardHeader>
              <CardContent className="flex-grow">
                <p className="text-sm text-muted-foreground">{failure.keyTakeaway}</p>
              </CardContent>
              <CardFooter>
                {failure.sourceUrl && (
                  <a
                    href={failure.sourceUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-sm text-blue-500 hover:underline flex items-center gap-1"
                  >
                    Source <ExternalLink className="h-4 w-4" />
                  </a>
                )}
              </CardFooter>
            </Card>
          ))}
        </div>
      )}

      {/* Pagination Controls */}
      <div className="flex items-center justify-center gap-4 mt-12">
        <Button asChild variant="outline" disabled={page <= 1}>
          <Link href={`/browse?page=${page - 1}&q=${searchQuery}`}>
            <ArrowLeft className="h-4 w-4 mr-2" /> Previous
          </Link>
        </Button>
        <span className="text-sm text-muted-foreground">
          Page {page} of {totalPages}
        </span>
        <Button asChild variant="outline" disabled={page >= totalPages}>
          <Link href={`/browse?page=${page + 1}&q=${searchQuery}`}>
            Next <ArrowRight className="h-4 w-4 ml-2" />
          </Link>
        </Button>
      </div>
    </div>
  );
}
// --- FILE: ./src/app/(pages)/page.tsx ---

'use client';

import React, { useState, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { cn } from '@/lib/utils';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import * as THREE from 'three';
import Logo from '@/components/Logo';
import Image from 'next/image';
import Link from 'next/link';

type Uniforms = {
  [key: string]: {
    value: number[] | number[][] | number;
    type: string;
  };
};

interface ShaderProps {
  source: string;
  uniforms: {
    [key: string]: {
      value: number[] | number[][] | number;
      type: string;
    };
  };
  maxFps?: number;
}

interface PageProps {
  className?: string;
}

const CanvasRevealEffect = ({
  animationSpeed = 10,
  opacities = [0.3, 0.3, 0.3, 0.5, 0.5, 0.5, 0.8, 0.8, 0.8, 1],
  colors = [[0, 255, 255]],
  containerClassName,
  dotSize,
  showGradient = true,
  reverse = false,
}: {
  animationSpeed?: number;
  opacities?: number[];
  colors?: number[][];
  containerClassName?: string;
  dotSize?: number;
  showGradient?: boolean;
  reverse?: boolean;
}) => {
  return (
    <div className={cn('h-full relative w-full', containerClassName)}>
      <div className="h-full w-full">
        <DotMatrix
          colors={colors ?? [[0, 255, 255]]}
          dotSize={dotSize ?? 3}
          opacities={
            opacities ?? [0.3, 0.3, 0.3, 0.5, 0.5, 0.5, 0.8, 0.8, 0.8, 1]
          }
          shader={`
            ${reverse ? 'u_reverse_active' : 'false'}_;
            animation_speed_factor_${animationSpeed.toFixed(1)}_;
          `}
          center={['x', 'y']}
        />
      </div>
      {showGradient && (
        <div className="absolute inset-0 bg-gradient-to-t from-black to-transparent" />
      )}
    </div>
  );
};

interface DotMatrixProps {
  colors?: number[][];
  opacities?: number[];
  totalSize?: number;
  dotSize?: number;
  shader?: string;
  center?: ('x' | 'y')[];
}

const DotMatrix: React.FC<DotMatrixProps> = ({
  colors = [[0, 0, 0]],
  opacities = [0.04, 0.04, 0.04, 0.04, 0.04, 0.08, 0.08, 0.08, 0.08, 0.14],
  totalSize = 20,
  dotSize = 2,
  shader = '',
  center = ['x', 'y'],
}) => {
  const uniforms = React.useMemo(() => {
    let colorsArray = [
      colors[0],
      colors[0],
      colors[0],
      colors[0],
      colors[0],
      colors[0],
    ];
    if (colors.length === 2) {
      colorsArray = [
        colors[0],
        colors[0],
        colors[0],
        colors[1],
        colors[1],
        colors[1],
      ];
    } else if (colors.length === 3) {
      colorsArray = [
        colors[0],
        colors[0],
        colors[1],
        colors[1],
        colors[2],
        colors[2],
      ];
    }
    return {
      u_colors: {
        value: colorsArray.map((color) => [
          color[0] / 255,
          color[1] / 255,
          color[2] / 255,
        ]),
        type: 'uniform3fv',
      },
      u_opacities: {
        value: opacities,
        type: 'uniform1fv',
      },
      u_total_size: {
        value: totalSize,
        type: 'uniform1f',
      },
      u_dot_size: {
        value: dotSize,
        type: 'uniform1f',
      },
      u_reverse: {
        value: shader.includes('u_reverse_active') ? 1 : 0,
        type: 'uniform1i',
      },
    };
  }, [colors, opacities, totalSize, dotSize, shader]);

  return (
    <Shader
      source={`
        precision mediump float;
        in vec2 fragCoord;

        uniform float u_time;
        uniform float u_opacities[10];
        uniform vec3 u_colors[6];
        uniform float u_total_size;
        uniform float u_dot_size;
        uniform vec2 u_resolution;
        uniform int u_reverse;

        out vec4 fragColor;

        float PHI = 1.61803398874989484820459;
        float random(vec2 xy) {
            return fract(tan(distance(xy * PHI, xy) * 0.5) * xy.x);
        }
        float map(float value, float min1, float max1, float min2, float max2) {
            return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
        }

        void main() {
            vec2 st = fragCoord.xy;
            ${center.includes('x')
          ? 'st.x -= abs(floor((mod(u_resolution.x, u_total_size) - u_dot_size) * 0.5));'
          : ''
        }
            ${center.includes('y')
          ? 'st.y -= abs(floor((mod(u_resolution.y, u_total_size) - u_dot_size) * 0.5));'
          : ''
        }

            float opacity = step(0.0, st.x);
            opacity *= step(0.0, st.y);

            vec2 st2 = vec2(int(st.x / u_total_size), int(st.y / u_total_size));

            float frequency = 5.0;
            float show_offset = random(st2);
            float rand = random(st2 * floor((u_time / frequency) + show_offset + frequency));
            opacity *= u_opacities[int(rand * 10.0)];
            opacity *= 1.0 - step(u_dot_size / u_total_size, fract(st.x / u_total_size));
            opacity *= 1.0 - step(u_dot_size / u_total_size, fract(st.y / u_total_size));

            vec3 color = u_colors[int(show_offset * 6.0)];

            float animation_speed_factor = 0.5;
            vec2 center_grid = u_resolution / 2.0 / u_total_size;
            float dist_from_center = distance(center_grid, st2);

            float timing_offset_intro = dist_from_center * 0.01 + (random(st2) * 0.15);

            float max_grid_dist = distance(center_grid, vec2(0.0, 0.0));
            float timing_offset_outro = (max_grid_dist - dist_from_center) * 0.02 + (random(st2 + 42.0) * 0.2);

            float current_timing_offset;
            if (u_reverse == 1) {
                current_timing_offset = timing_offset_outro;
                 opacity *= 1.0 - step(current_timing_offset, u_time * animation_speed_factor);
                 opacity *= clamp((step(current_timing_offset + 0.1, u_time * animation_speed_factor)) * 1.25, 1.0, 1.25);
            } else {
                current_timing_offset = timing_offset_intro;
                 opacity *= step(current_timing_offset, u_time * animation_speed_factor);
                 opacity *= clamp((1.0 - step(current_timing_offset + 0.1, u_time * animation_speed_factor)) * 1.25, 1.0, 1.25);
            }

            fragColor = vec4(color, opacity);
            fragColor.rgb *= fragColor.a;
        }`}
      uniforms={uniforms}
      maxFps={60}
    />
  );
};

const ShaderMaterial = ({
  source,
  uniforms,
  maxFps = 60,
}: {
  source: string;
  hovered?: boolean;
  maxFps?: number;
  uniforms: Uniforms;
}) => {
  const { size } = useThree();
  const ref = useRef<THREE.Mesh>(null);
  let lastFrameTime = 0;

  useFrame(({ clock }) => {
    if (!ref.current) return;
    const timestamp = clock.getElapsedTime();

    lastFrameTime = timestamp;

    const material: any = ref.current.material;
    const timeLocation = material.uniforms.u_time;
    timeLocation.value = timestamp;
  });

  const getUniforms = () => {
    const preparedUniforms: any = {};

    for (const uniformName in uniforms) {
      const uniform: any = uniforms[uniformName];

      switch (uniform.type) {
        case 'uniform1f':
          preparedUniforms[uniformName] = { value: uniform.value, type: '1f' };
          break;
        case 'uniform1i':
          preparedUniforms[uniformName] = { value: uniform.value, type: '1i' };
          break;
        case 'uniform3f':
          preparedUniforms[uniformName] = {
            value: new THREE.Vector3().fromArray(uniform.value),
            type: '3f',
          };
          break;
        case 'uniform1fv':
          preparedUniforms[uniformName] = { value: uniform.value, type: '1fv' };
          break;
        case 'uniform3fv':
          preparedUniforms[uniformName] = {
            value: uniform.value.map((v: number[]) =>
              new THREE.Vector3().fromArray(v),
            ),
            type: '3fv',
          };
          break;
        case 'uniform2f':
          preparedUniforms[uniformName] = {
            value: new THREE.Vector2().fromArray(uniform.value),
            type: '2f',
          };
          break;
        default:
          console.error(`Invalid uniform type for '${uniformName}'.`);
          break;
      }
    }

    preparedUniforms['u_time'] = { value: 0, type: '1f' };
    preparedUniforms['u_resolution'] = {
      value: new THREE.Vector2(size.width * 2, size.height * 2),
    };
    return preparedUniforms;
  };

  const material = React.useMemo(() => {
    const materialObject = new THREE.ShaderMaterial({
      vertexShader: `
      precision mediump float;
      in vec2 coordinates;
      uniform vec2 u_resolution;
      out vec2 fragCoord;
      void main(){
        float x = position.x;
        float y = position.y;
        gl_Position = vec4(x, y, 0.0, 1.0);
        fragCoord = (position.xy + vec2(1.0)) * 0.5 * u_resolution;
        fragCoord.y = u_resolution.y - fragCoord.y;
      }
      `,
      fragmentShader: source,
      uniforms: getUniforms(),
      glslVersion: THREE.GLSL3,
      blending: THREE.CustomBlending,
      blendSrc: THREE.SrcAlphaFactor,
      blendDst: THREE.OneFactor,
    });

    return materialObject;
  }, [size.width, size.height, source]);

  return (
    <mesh ref={ref as any}>
      <planeGeometry args={[2, 2]} />
      <primitive object={material} attach="material" />
    </mesh>
  );
};

const Shader: React.FC<ShaderProps> = ({ source, uniforms, maxFps = 60 }) => {
  return (
    <Canvas className="absolute inset-0  h-full w-full">
      <ShaderMaterial source={source} uniforms={uniforms} maxFps={maxFps} />
    </Canvas>
  );
};

const AnimatedNavLink = ({
  href,
  children,
  onClick,
}: {
  href: string;
  children: React.ReactNode;
  onClick?: () => void;
}) => {
  const defaultTextColor = 'text-gray-300';
  const hoverTextColor = 'text-white';
  const textSizeClass = 'text-sm';

  const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
    e.preventDefault();
    if (onClick) {
      onClick();
    }
  };

  return (
    <a
      href={href}
      onClick={handleClick}
      className={`group relative inline-block overflow-hidden h-5 flex items-center ${textSizeClass}`}
    >
      <div className="flex flex-col transition-transform duration-400 ease-out transform group-hover:-translate-y-1/2">
        <span className={defaultTextColor}>{children}</span>
        <span className={hoverTextColor}>{children}</span>
      </div>
    </a>
  );
};

interface DialogProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

const Dialog: React.FC<DialogProps> = ({ isOpen, onClose, children }) => {
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }

    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [isOpen]);

  return (
    <AnimatePresence>
      {isOpen && (
        <>
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50"
            onClick={onClose}
          />
          <motion.div
            initial={{ opacity: 0, scale: 0.9, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.9, y: 20 }}
            transition={{ duration: 0.3, ease: 'easeOut' }}
            className="fixed inset-0 flex items-center justify-center z-50 px-4"
          >
            <div
              className="relative w-full max-w-lg backdrop-blur-md bg-[#1f1f1f57] border border-[#333] rounded-2xl p-8"
              onClick={(e) => e.stopPropagation()}
            >
              <button
                onClick={onClose}
                className="absolute top-4 right-4 text-white/50 hover:text-white transition-colors"
              >
                <svg
                  className="w-6 h-6"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M6 18L18 6M6 6l12 12"
                  ></path>
                </svg>
              </button>
              {children}
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  );
};

// Dialog Content Components
const AboutContent = () => (
  <div className="space-y-6 text-center">
    <h2 className="text-3xl font-bold text-white">About Cassandra</h2>
    <div className="space-y-4 text-white/70">
      <p>
        The vast majority of startups fail, often due to preventable mistakes. We believe the lessons from these failures are the most valuable resource for new founders.
      </p>
      <p>
        Cassandra is an AI co-pilot trained on a "Corpus of Failure"—a knowledge base of over 1,000 detailed startup post-mortems. It analyzes your idea to identify potential pitfalls before they happen.
      </p>
      <p>
        Our mission is to equip innovators with data-driven foresight, turning the graveyard of failed startups into a roadmap for success.
      </p>
    </div>
  </div>
);

const JourneyContent = () => (
  <div className="space-y-6">
    <h2 className="text-3xl font-bold text-white text-center">
      How It Works
    </h2>
    <div className="space-y-6">
      <div className="space-y-2">
        <h3 className="text-xl font-semibold text-white flex items-center gap-2">
          <span className="w-2 h-2 bg-amber-400 rounded-full"></span>
          Step 1: Deconstruction & Analysis
        </h3>
        <p className="text-white/70 ml-4">
          Our agentic system deconstructs your pitch into core components—market, product, team, timing—and queries our knowledge base for relevant failure patterns.
        </p>
      </div>
      <div className="space-y-2">
        <h3 className="text-xl font-semibold text-white flex items-center gap-2">
          <span className="w-2 h-2 bg-amber-400/60 rounded-full"></span>
          Step 2: Risk Identification
        </h3>
        <p className="text-white/70 ml-4">
          The AI identifies and scores the most critical risks your venture faces, from "No Market Need" to "Poor Monetization," based on historical data.
        </p>
      </div>
      <div className="space-y-2">
        <h3 className="text-xl font-semibold text-white flex items-center gap-2">
          <span className="w-2 h-2 bg-amber-400/30 rounded-full"></span>
          Step 3: Actionable Synthesis
        </h3>
        <p className="text-white/70 ml-4">
          Receive an interactive report with risk gauges, mitigation strategies, and case studies, allowing you to de-risk your plan and engineer for success.
        </p>
      </div>
    </div>
  </div>
);

const ContactContent = () => {
  return (
    <div className="space-y-6">
      <h2 className="text-3xl font-bold text-white text-center">
        Get in Touch
      </h2>
      <p className="text-white/70 text-center">
        Cassandra is a project born from a passion for helping founders succeed. We are constantly evolving and would love to hear your feedback, questions, or ideas.
      </p>
      <div className="pt-4">
        <a href="mailto:contact@example.com">
          <button
            className="w-full rounded-full bg-white text-black font-medium py-3 hover:bg-white/90 transition-colors flex items-center justify-center gap-3"
          >
            Contact The Team
          </button>
        </a>
      </div>
      <p className="text-xs text-white/40 text-center pt-4">
        Let's connect and explore how we can build more resilient ventures together.
      </p>
    </div>
  );
};

function MiniNavbar() {
  const [isOpen, setIsOpen] = useState(false);
  const [headerShapeClass, setHeaderShapeClass] = useState('rounded-full');
  const shapeTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [activeDialog, setActiveDialog] = useState<string | null>(null);

  const toggleMenu = () => {
    setIsOpen(!isOpen);
  };

  useEffect(() => {
    if (shapeTimeoutRef.current) {
      clearTimeout(shapeTimeoutRef.current);
    }

    if (isOpen) {
      setHeaderShapeClass('rounded-xl');
    } else {
      shapeTimeoutRef.current = setTimeout(() => {
        setHeaderShapeClass('rounded-full');
      }, 300);
    }

    return () => {
      if (shapeTimeoutRef.current) {
        clearTimeout(shapeTimeoutRef.current);
      }
    };
  }, [isOpen]);

  const logoElement = <Logo className="!text-white"/>;

  const navLinksData = [
    { label: 'About', href: '#about' },
    { label: 'How It Works', href: '#journey' },
    { label: 'Contact', href: '#contact' },
  ];

  const startButtonElement = (
    <div className="relative group w-full sm:w-auto">
      <div
        className="absolute inset-0 -m-2 rounded-full
                     hidden sm:block
                     bg-gray-100
                     opacity-40 filter blur-lg pointer-events-none
                     transition-all duration-300 ease-out
                     group-hover:opacity-60 group-hover:blur-xl group-hover:-m-3"
      ></div>
      <button className="relative z-10 px-4 py-2 sm:px-3 text-xs sm:text-sm font-semibold text-black bg-gradient-to-br from-gray-100 to-gray-300 rounded-full hover:from-gray-200 hover:to-gray-400 transition-all duration-200 w-full sm:w-auto">
        Start Analysis
      </button>
    </div>
  );

  const handleNavClick = (label: string) => {
    if (label === "How It Works") {
      setActiveDialog("journey");
    } else {
      setActiveDialog(label.toLowerCase());
    }
  };

  const getDialogContent = () => {
    switch (activeDialog) {
      case 'about':
        return <AboutContent />;
      case 'journey':
        return <JourneyContent />;
      case 'contact':
        return <ContactContent />;
      default:
        return null;
    }
  };

  return (
    <>
      <header
        className={`fixed top-6 left-1/2 transform -translate-x-1/2 z-20
                         flex flex-col items-center
                         pl-6 pr-6 py-3 backdrop-blur-sm
                         ${headerShapeClass}
                         border border-[#333] bg-[#1f1f1f57]
                         w-[calc(100%-2rem)] sm:w-auto
                         transition-[border-radius] duration-0 ease-in-out`}
      >
        <div className="flex items-center justify-between w-full gap-x-6 sm:gap-x-8">
          <div className="flex items-center">{logoElement}</div>

          <nav className="hidden sm:flex items-center space-x-4 sm:space-x-6 text-sm">
            {navLinksData.map((link) => (
              <AnimatedNavLink
                key={link.href}
                href={link.href}
                onClick={() => handleNavClick(link.label)}
              >
                {link.label}
              </AnimatedNavLink>
            ))}
          </nav>

          <div className="hidden sm:flex items-center gap-2 sm:gap-3">
            <a href="/dashboard">{startButtonElement}</a>
          </div>

          <button
            className="sm:hidden flex items-center justify-center w-8 h-8 text-gray-300 focus:outline-none"
            onClick={toggleMenu}
            aria-label={isOpen ? 'Close Menu' : 'Open Menu'}
          >
            {isOpen ? (
              <svg
                className="w-6 h-6"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M6 18L18 6M6 6l12 12"
                ></path>
              </svg>
            ) : (
              <svg
                className="w-6 h-6"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M4 6h16M4 12h16M4 18h16"
                ></path>
              </svg>
            )}
          </button>
        </div>

        <div
          className={`sm:hidden flex flex-col items-center w-full transition-all ease-in-out duration-300 overflow-hidden
                         ${isOpen ? 'max-h-[1000px] opacity-100 pt-4' : 'max-h-0 opacity-0 pt-0 pointer-events-none'}`}
        >
          <nav className="flex flex-col items-center space-y-4 text-base w-full">
            {navLinksData.map((link) => (
              <a
                key={link.href}
                href={link.href}
                onClick={(e) => {
                  e.preventDefault();
                  handleNavClick(link.label);
                  setIsOpen(false);
                }}
                className="text-gray-300 hover:text-white transition-colors w-full text-center"
              >
                {link.label}
              </a>
            ))}
          </nav>
          <div className="flex flex-col items-center space-y-4 mt-4 w-full">
            <a href="/dashboard">{startButtonElement}</a>
          </div>
        </div>
      </header>

      <Dialog isOpen={!!activeDialog} onClose={() => setActiveDialog(null)}>
        {getDialogContent()}
      </Dialog>
    </>
  );
}

const LandingPage = ({ className }: PageProps) => {
  const [pitch, setPitch] = useState('');

  const handlePitchSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (pitch) {
      const encodedPitch = encodeURIComponent(pitch);
      window.location.href = `/dashboard?pitch=${encodedPitch}`;
    }
  };

  return (
    <div
      className={cn(
        'flex w-[100%] flex-col min-h-screen bg-black relative',
        className,
      )}
    >
      <div className="absolute inset-0 z-0">
        <div className="absolute inset-0">
          <CanvasRevealEffect
            animationSpeed={3}
            containerClassName="bg-black"
            colors={[
              [251, 191, 36], // Amber-400
              [251, 191, 36], // Amber-400
            ]}
            dotSize={2}
            reverse={false}
          />
        </div>

        <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_rgba(0,0,0,1)_0%,_transparent_100%)]" />
        <div className="absolute top-0 left-0 right-0 h-1/3 bg-gradient-to-b from-black to-transparent" />
      </div>

      {/* Content Layer */}
      <div className="relative z-10 flex flex-col flex-1">
        {/* Top navigation */}
        <MiniNavbar />

        {/* Main content container */}
        <div className="flex flex-1 flex-col justify-center items-center px-4">
          <div className="w-full max-w-2xl">
            <motion.div
              key="pitch-query-step"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.4, ease: 'easeOut' }}
              className="space-y-6 text-center"
            >
              <div className="space-y-3">
                <h1 className="text-[2.9rem] font-light leading-[1.1] tracking-tight text-white">
                  Forecast Failure. Engineer Success.
                </h1>
                <h2 className="text-[1rem] text-white/70 font-light">
                  Analyze your venture against a knowledge base of 1,000+ startup failures.
                </h2>
              </div>

              <div className="space-y-4">
                <form onSubmit={handlePitchSubmit}>
                  <div className="relative">
                    <input
                      type="text"
                      placeholder="Enter your pitch, business plan, or new feature idea..."
                      value={pitch}
                      onChange={(e) => setPitch(e.target.value)}
                      className="w-full backdrop-blur-[1px] text-white border-1 border-white/10 rounded-full py-3 px-4 pr-12 focus:outline-none focus:border focus:border-white/30 text-center"
                      required
                    />
                    <button
                      type="submit"
                      className="absolute right-1.5 top-1.5 text-white w-9 h-9 flex items-center justify-center rounded-full bg-white/10 hover:bg-white/20 transition-colors group overflow-hidden"
                    >
                      <span className="relative w-full h-full block overflow-hidden">
                        <span className="absolute inset-0 flex items-center justify-center transition-transform duration-300 group-hover:translate-x-full">
                          →
                        </span>
                        <span className="absolute inset-0 flex items-center justify-center transition-transform duration-300 -translate-x-full group-hover:translate-x-0">
                          →
                        </span>
                      </span>
                    </button>
                  </div>
                </form>
              </div>

              <p className="text-xs text-white/40 pt-10">
                De-risk your idea with an AI co-pilot that has studied the startup graveyard.
              </p>
            </motion.div>
          </div>
        </div>

        <footer className="relative z-10 py-6 px-6">
  <div className="max-w-7xl mx-auto flex flex-col items-center space-y-8">
    <motion.div
      className="flex w-full flex-col items-center gap-4"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ delay: 1.2 }}
    >
      <Link href="https://tidb-2025-hackathon.devpost.com/." target="_blank" rel="noopener noreferrer">
      <span className="text-sm text-white/40 hover:text-white transition-colors">Proudly supported by our hackathon partners</span>
      </Link>
      <div className="flex items-center justify-center gap-x-10 md:gap-x-12">
        <a href="https://moonshot.ai/" target="_blank" rel="noopener noreferrer" title="Kimi AI" className="transition-all duration-300 grayscale hover:grayscale-0 opacity-60 hover:opacity-100">
          <Image
            src="/kimi.png"
            alt="Kimi AI Logo"
            width={80}
            height={32}
            className="h-8 w-auto"
          />
        </a>
        <a href="https://dify.ai/" target="_blank" rel="noopener noreferrer" title="Dify.ai" className="transition-all duration-300 grayscale hover:grayscale-0 opacity-60 hover:opacity-100">
          <div className="bg-white rounded-md p-1 flex items-center justify-center">
            <Image
              src="/dify.png"
              alt="Dify.ai Logo"
              width={53}
              height={24}
              className="h-6 w-auto"
            />
          </div>
        </a>
        <a href="https://www.pingcap.com/tidb/" target="_blank" rel="noopener noreferrer" title="TiDB" className="transition-all duration-300 grayscale hover:grayscale-0 opacity-60 hover:opacity-100">
          {/* --- CHANGE IS HERE --- */}
          <Image
            src="/tidb-logo.svg"
            alt="TiDB Logo"
            width={90}
            height={32}
            className="h-8 w-auto [filter:drop-shadow(0_0_3px_rgba(255,255,255,0.7))]"
          />
        </a>
        <a href="https://aws.amazon.com/" target="_blank" rel="noopener noreferrer" title="AWS" className="transition-all duration-300 grayscale hover:grayscale-0 opacity-60 hover:opacity-100">
          <Image
            src="/aws.png"
            alt="AWS Logo"
            width={50}
            height={32}
            className="h-8 w-auto invert"
          />
        </a>

        <a href="https://sheet0.org/" target="_blank" rel="noopener noreferrer" title="Sheet0" className="transition-all duration-300 grayscale hover:grayscale-0 opacity-60 hover:opacity-100">
          <Image
            src="/sheet0.png"
            alt="Sheet0 Logo"
            width={50}
            height={32}
            className="h-8 w-auto invert"
          />
        </a>
      </div>
    </motion.div>
  </div>
</footer>
      </div>
    </div>
  );
};

export default function Page() {
  return <LandingPage />;
}
// --- FILE: ./src/app/layout.tsx ---

import type { Metadata } from 'next'
import { Geist, Geist_Mono } from 'next/font/google'
import './globals.css'
import { ThemeProvider } from '@/components/theme-provider' // <-- Import ThemeProvider

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin'],
})

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
})

export const metadata: Metadata = {
  title: 'Cassandra',
  description: 'AI co-pilot for startup founders',
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          {children}
        </ThemeProvider>
      </body>
    </html>
  )
}
// --- FILE: ./src/app/api/analyze/route.ts ---

// --- FILE: src/app/api/analyze/route.ts ---

import { NextRequest, NextResponse } from 'next/server';
import { Prisma } from '@prisma/client'; // <-- CORRECT IMPORT: Only the Prisma namespace
import OpenAI from 'openai';
import prisma from '@/lib/prisma';
import { generateEmbedding } from '@/lib/embedding';

const kimi = new OpenAI({
  apiKey: process.env.MOONSHOT_API_KEY,
  baseURL: 'https://api.moonshot.ai/v1',
});

// Define a type for the raw query result
type FailureCaseResult = {
  id: number;
  company_name: string;
  failure_reason: string;
  summary: string;
  source_url: string | null;
  distance?: number;
  score?: number;
};

export async function POST(req: NextRequest) {
  try {
    const formData = await req.formData();
    const pitch = formData.get('pitch') as string;
    const file = formData.get('file') as File | null;
    const parentPitch = formData.get('parentPitch') as string | null;
    const parentAnalysis = formData.get('parentAnalysis') as string | null;

    if (!pitch && !file) {
      return new NextResponse(JSON.stringify({ error: 'Pitch or file is required' }), { status: 400 });
    }

    const contextSections: string[] = [];

    // Agent Step 0: Handle conversational context
    if (parentPitch) {
      let parentContext = `--- Previous Context ---\nPrevious Pitch: "${parentPitch}"`;
      if (parentAnalysis) {
        parentContext += `\n\nPrevious Analysis:\n${parentAnalysis}`;
      }
      contextSections.push(parentContext);
    }

    // Agent Step 1: Handle file upload
    if (file) {
      try {
        const fileContent = await file.text();
        if (fileContent) {
          contextSections.push(`--- Uploaded File Content ---\n${fileContent.substring(0, 5000)}...`);
        }
      } catch (fileError) {
        console.error('Error reading file content:', fileError);
        contextSections.push("--- NOTE ---\nFile processing failed, analysis will proceed without file context.");
      }
    }

    // Agent Step 2: HYBRID SEARCH from vector database
    const textForEmbedding = pitch || `Analysis of the document named ${file?.name}`;
    
    // Query 1: Vector Search (for conceptual similarity)
    const pitchVector = await generateEmbedding(textForEmbedding);
    const vectorSearchPromise = prisma.$queryRaw<FailureCaseResult[]>`
      SELECT id, company_name, failure_reason, summary, source_url,
             VEC_COSINE_DISTANCE(summary_vector, CAST(${JSON.stringify(pitchVector)} AS VECTOR(1536))) as distance
      FROM startup_failures
      ORDER BY distance ASC
      LIMIT 3
    `;

    // Query 2: Full-Text Search (for factual/keyword similarity)
    // <-- CORRECT USAGE: Using the namespaced Prisma.sql helper
    const fullTextSearchPromise = prisma.$queryRaw`
        SELECT id, company_name, failure_reason, summary, source_url,
               MATCH(companyName, failureReason, summary, whatWentWrong) AGAINST(${pitch} IN NATURAL LANGUAGE MODE) as score
        FROM startup_failures 
        WHERE MATCH(companyName, failureReason, summary, whatWentWrong) AGAINST(${pitch} IN NATURAL LANGUAGE MODE)
        ORDER BY score DESC 
        LIMIT 3
      `

    // Execute both queries in parallel
    const [vectorResults, textResults]: any = await Promise.all([vectorSearchPromise, fullTextSearchPromise]);

    // Combine and de-duplicate the results
    const combinedResults = new Map<number, FailureCaseResult>();
    [...vectorResults, ...textResults].forEach(res => {
      if (!combinedResults.has(res.id)) {
        combinedResults.set(res.id, res);
      }
    });
    
    const dbContext = Array.from(combinedResults.values())
      .map(row => `- Company: ${row.company_name} (Source: ${row.source_url || '#no-source'})\n  Reason for Failure: ${row.failure_reason}\n  Summary: ${row.summary}`)
      .join('\n\n');
      
    if (dbContext) {
        contextSections.push(`--- Relevant Case Studies (from Hybrid Search) ---\n${dbContext}`);
    }

    const fullContext = contextSections.join('\n\n');

    // Agent Step 3: Construct the enhanced, structured prompt
    const systemPrompt = `You are Cassandra, an AI co-pilot for startup founders. Your goal is to identify potential risks by comparing a user's pitch to a database of failed startups and any provided documents. You are critical, insightful, and constructive.`;
    
    const userPrompt = `Based on my pitch and the provided context, perform a critical risk analysis.

      **My Pitch:**
      "${pitch}"

      **Context for your analysis:**
      ${fullContext}
      
      **Your Task:**
      1.  **First, you MUST output a valid JSON object.** This object must have a single key "risk_analysis" which is an array of objects. Each object in the array represents a single, primary risk and MUST have three keys:
          - "risk_name": A short, descriptive name for the risk (e.g., "Market Saturation", "User Retention Issues").
          - "score": An integer from 1 to 10, where 10 is the highest possible risk.
          - "summary": A one-sentence summary of the risk and a potential mitigation.
      2.  **After the JSON object, add a "---" separator.**
      3.  **After the separator, provide your full, detailed analysis in Markdown.** Elaborate on the risks you identified. Use headings, bold text, and bullet points for clarity.
      
      **IMPORTANT RULES for the Markdown analysis:**
      - When you reference a specific case study from the "Relevant Case Studies" section, you MUST cite it as a Markdown link using its provided Source URL. For example: "Similar to the issues faced by [Webvan](https://www.failory.com/cemetery/webvan), you might struggle with logistics."
      - Be direct and constructive. Don't just list problems; suggest actionable next steps or questions the founder should answer.
    `;

    // Agent Step 4: Stream the response from Kimi
    const stream = await kimi.chat.completions.create({
      model: 'kimi-k2-turbo-preview',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
      stream: true,
      temperature: 0.5,
    });

    const readableStream = new ReadableStream({
      async start(controller) {
        for await (const chunk of stream) {
          const content = chunk.choices[0]?.delta?.content || '';
          controller.enqueue(new TextEncoder().encode(content));
        }
        controller.close();
      },
    });

    return new Response(readableStream, {
      headers: { 'Content-Type': 'application/json; charset=utf-8' },
    });

  } catch (error) {
    console.error('Error in /api/analyze:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return new NextResponse(JSON.stringify({ error: 'An internal error occurred', details: errorMessage }), { status: 500 });
  }
}
// --- FILE: ./src/app/globals.css ---

@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

/* Light Theme (Inspired by the Reference) */
:root {
  --radius: 0.75rem;
  --background: oklch(1 0 0); /* White */
  --foreground: oklch(0.18 0.01 240); /* Near Black */
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.18 0.01 240);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.18 0.01 240);
  --primary: oklch(0.45 0.22 260); /* Vibrant Purple/Blue */
  --primary-foreground: oklch(0.98 0.01 260); /* Light text for primary */
  --secondary: oklch(0.45 0.22 260); /* Using primary color for accents */
  --secondary-foreground: oklch(0.98 0.01 260);
  --muted: oklch(0.96 0.01 240); /* Light Gray */
  --muted-foreground: oklch(0.45 0.01 240); /* Medium Gray */
  --accent: oklch(0.96 0.01 240);
  --accent-foreground: oklch(0.18 0.01 240);
  --destructive: oklch(0.58 0.24 27);
  --border: oklch(0.9 0.01 240); /* Light border */
  --input: oklch(0.9 0.01 240);
  --ring: oklch(0.45 0.22 260);
}

/* Dark Theme (Inspired by the Reference) */
.dark {
  --background: oklch(0.09 0.01 240); /* Very Dark Blue/Gray */
  --foreground: oklch(0.95 0.01 240); /* Light Gray text */
  --card: oklch(0.09 0.01 240);
  --card-foreground: oklch(0.95 0.01 240);
  --popover: oklch(0.09 0.01 240);
  --popover-foreground: oklch(0.95 0.01 240);
  --primary: oklch(0.65 0.2 260); /* Lighter Purple/Blue */
  --primary-foreground: oklch(0.1 0.01 260);
  --secondary: oklch(0.65 0.2 260);
  --secondary-foreground: oklch(0.1 0.01 260);
  --muted: oklch(0.15 0.01 240); /* Dark Gray */
  --muted-foreground: oklch(0.65 0.01 240); /* Medium-light Gray */
  --accent: oklch(0.15 0.01 240);
  --accent-foreground: oklch(0.95 0.01 240);
  --destructive: oklch(0.6 0.2 25);
  --border: oklch(0.2 0.01 240); /* Dark border */
  --input: oklch(0.2 0.01 240);
  --ring: oklch(0.65 0.2 260);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground antialiased;
  }
}
// --- FILE: ./src/components/theme-provider.tsx ---

'use client'

import * as React from 'react'
import { ThemeProvider as NextThemesProvider } from 'next-themes'
import { type ThemeProviderProps } from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
// --- FILE: ./src/components/ui/card.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

// --- FILE: ./src/components/ui/sheet.tsx ---

"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

// --- FILE: ./src/components/ui/scroll-area.tsx ---

"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }

// --- FILE: ./src/components/ui/tooltip.tsx ---

"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

// --- FILE: ./src/components/ui/avatar.tsx ---

"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }

// --- FILE: ./src/components/ui/badge.tsx ---

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }

// --- FILE: ./src/components/ui/separator.tsx ---

"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

// --- FILE: ./src/components/ui/button.tsx ---

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

// --- FILE: ./src/components/ui/dropdown-menu.tsx ---

"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}

// --- FILE: ./src/components/ui/textarea.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }

// --- FILE: ./src/components/ui/input.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

// --- FILE: ./src/components/PitchNode.tsx ---

// --- FILE: src/components/PitchNode.tsx ---
"use client";

import React, { useState, useEffect, useRef, FC } from 'react';
import Image from 'next/image';
import { Handle, Position, NodeProps } from 'reactflow';
import { motion, AnimatePresence } from 'framer-motion';
import ReactMarkdown from 'react-markdown';
import { ArrowRight, Plus, Loader2, SendHorizonal, Paperclip, X, Mic, AlertTriangle } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useAudioInput } from '@/hooks/use-audio-input';
import { PitchNodeData, Risk } from './DashboardContext';

// --- Custom renderer for Markdown links to show favicons ---
const MarkdownLinkRenderer: FC<React.PropsWithChildren<any>> = ({ href, children }) => {
  try {
    const hostname = new URL(href).hostname;
    const faviconUrl = `https://www.google.com/s2/favicons?sz=32&domain_url=${hostname}`;
    return (
      <a href={href} target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-1.5 not-prose font-medium hover:underline decoration-amber-500/50">
        <Image src={faviconUrl} alt={`${hostname} favicon`} width={16} height={16} className="flex-shrink-0 rounded-sm" unoptimized />
        <span>{children}</span>
      </a>
    );
  } catch (error) {
    return <a href={href} target="_blank" rel="noopener noreferrer">{children}</a>;
  }
};

// --- NEW: Risk Scorecard Component ---
const RiskScorecard: FC<{ analysis: { risk_analysis: Risk[] } }> = ({ analysis }) => {
  if (!analysis?.risk_analysis?.length) return null;

  const getRiskColor = (score: number) => {
    if (score >= 8) return 'bg-red-500';
    if (score >= 5) return 'bg-amber-500';
    return 'bg-green-500';
  };

  return (
    <div className="space-y-4 my-4">
      <h3 className="text-sm font-semibold text-zinc-800 dark:text-zinc-200 flex items-center gap-2">
        <AlertTriangle className="h-4 w-4 text-amber-500" />
        Primary Risks Identified
      </h3>
      <div className="space-y-3">
        {analysis.risk_analysis.map((risk, index) => (
          <motion.div
            key={risk.risk_name}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3, delay: index * 0.1 }}
            className="text-xs"
          >
            <div className="flex justify-between items-center mb-1">
              <span className="font-medium text-zinc-700 dark:text-zinc-300">{risk.risk_name}</span>
              <span className="font-semibold text-zinc-800 dark:text-zinc-200">{risk.score}/10</span>
            </div>
            <div className="w-full bg-zinc-200 dark:bg-zinc-700 rounded-full h-1.5">
              <div
                className={cn("h-1.5 rounded-full", getRiskColor(risk.score))}
                style={{ width: `${risk.score * 10}%` }}
              />
            </div>
            <p className="text-zinc-500 dark:text-zinc-400 mt-1.5">{risk.summary}</p>
          </motion.div>
        ))}
      </div>
    </div>
  );
};


const PitchNode: React.FC<NodeProps<PitchNodeData>> = (node) => {
  const { id, data } = node;
  const [currentPitch, setCurrentPitch] = useState(data.pitch || '');
  const [file, setFile] = useState<File | null>(null);
  const [isEditing, setIsEditing] = useState(!data.pitch);
  const textAreaRef = useRef<HTMLTextAreaElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleTranscript = (transcript: string) => {
    setCurrentPitch(prev => prev + transcript + ' ');
    setIsEditing(true);
  };

  const { isListening, toggleListening, error } = useAudioInput(handleTranscript);

  useEffect(() => {
    setCurrentPitch(data.pitch || '');
    if (data.pitch) setIsEditing(!!data.pitch && !data.response);
  }, [data.pitch, data.response]);


  useEffect(() => {
    if (textAreaRef.current) {
      textAreaRef.current.style.height = 'auto';
      textAreaRef.current.style.height = `${textAreaRef.current.scrollHeight}px`;
    }
  }, [currentPitch, data.response]);

  useEffect(() => {
    if (isEditing) textAreaRef.current?.focus();
  }, [isEditing]);

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files[0]) setFile(event.target.files[0]);
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if ((currentPitch.trim() || file) && !data.isLoading) {
      setIsEditing(false);
      data.onAnalysis(id, currentPitch, file);
    }
  };

  const isAnalysisComplete = !data.isLoading && data.response && data.response.length > 0;
  const hasAnalysisStarted = data.isLoading || !!data.response || !!data.structuredResponse;

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.9, y: 10 }}
      animate={{ opacity: 1, scale: 1, y: 0 }}
      transition={{ duration: 0.2, ease: 'easeOut' }}
      className="bg-white dark:bg-zinc-900 border-2 border-zinc-200 dark:border-zinc-700 rounded-lg shadow-xl w-[500px] text-black dark:text-white flex flex-col"
    >
      <Handle type="target" position={Position.Top} className="!w-full !h-2 !-top-1 !bg-transparent !border-none" />

      <div className="flex items-center justify-between p-3 border-b border-zinc-200 dark:border-zinc-700 flex-shrink-0">
          <div className="flex items-center gap-2">
              <Image src="/kimi.png" alt="Kimi Logo" width={20} height={20}/>
              <span className="text-sm font-medium text-zinc-800 dark:text-zinc-200">Kimi K2 Turbo</span>
          </div>
          <button className="p-1 rounded-md text-zinc-500 hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors" title="New Chat (coming soon)">
              <Plus size={16} />
          </button>
      </div>

      {data.contextTitle && (
          <div className="flex items-center gap-2 p-3 border-b border-zinc-200 dark:border-zinc-700 text-xs text-zinc-500 dark:text-zinc-400 flex-shrink-0">
              <ArrowRight size={14} className="shrink-0" />
              <span className="truncate">{data.contextTitle}</span>
          </div>
      )}

      <div className="p-4 space-y-4">
        {hasAnalysisStarted ? (
          <div>
            {file && (
              <div className="mb-2 flex items-center gap-2 text-xs bg-zinc-100 dark:bg-zinc-800 rounded-full px-3 py-1 w-fit">
                <Paperclip size={12} className="text-zinc-500"/>
                <span className="text-zinc-700 dark:text-zinc-300">{file.name}</span>
              </div>
            )}
            <p className="text-sm text-zinc-800 dark:text-zinc-200 whitespace-pre-wrap">{currentPitch}</p>
          </div>
        ) : (
          <form onSubmit={handleSubmit} className="flex flex-col">
            <div className="relative">
              <div className="min-h-[60px]" onClick={() => setIsEditing(true)}>
                {isEditing || currentPitch ? (
                  <textarea ref={textAreaRef} value={currentPitch} onChange={(e) => setCurrentPitch(e.target.value)} onBlur={() => { if (!currentPitch) setIsEditing(false); }} className="w-full bg-transparent border-none p-0 pt-2 text-sm focus:outline-none focus:ring-0 resize-none overflow-hidden" rows={1}/>
                ) : (
                  <p className="text-zinc-500 dark:placeholder-zinc-400 cursor-text absolute top-2 left-0">
                    Describe your startup idea, or attach a file...
                  </p>
                )}
              </div>
              <button type="submit" className="absolute top-2 right-0 p-2 rounded-full text-zinc-400 hover:bg-zinc-200 dark:hover:bg-zinc-700 disabled:opacity-50" disabled={!((currentPitch || '').trim() || file) || data.isLoading} title="Send Prompt">
                <SendHorizonal size={16}/>
              </button>
            </div>
            
            <div className="flex items-center justify-between mt-2">
              <div className="flex items-center gap-1">
                <input type="file" ref={fileInputRef} onChange={handleFileChange} className="hidden" />
                <button type="button" onClick={() => fileInputRef.current?.click()} className="p-2 rounded-full text-zinc-400 hover:bg-zinc-200 dark:hover:bg-zinc-700" title="Attach File">
                  <Paperclip size={16}/>
                </button>
                <button type="button" onClick={toggleListening} className={cn("p-2 rounded-full transition-colors", isListening ? "bg-red-500/20 text-red-500 animate-pulse" : "text-zinc-400 hover:bg-zinc-200 dark:hover:bg-zinc-700")} title="Record Audio">
                    <Mic size={16} />
                </button>
                {file && (
                  <div className="flex items-center gap-2 text-xs bg-zinc-100 dark:bg-zinc-800 rounded-full px-3 py-1 w-fit animate-in fade-in-50">
                    <Paperclip size={12} className="text-zinc-500"/>
                    <span className="text-zinc-700 dark:text-zinc-300 max-w-48 truncate">{file.name}</span>
                    <button type="button" onClick={() => { setFile(null); if (fileInputRef.current) fileInputRef.current.value = ''; }} className="ml-1 p-0.5 rounded-full hover:bg-zinc-200 dark:hover:bg-zinc-700"><X size={12}/></button>
                  </div>
                )}
              </div>
               {error && <p className="text-xs text-red-500">{error}</p>}
            </div>
          </form>
        )}

        {hasAnalysisStarted && (
            <div className="pt-4 border-t border-zinc-200 dark:border-zinc-700">
                {data.isLoading && !data.response && !data.structuredResponse && (
                    <div className="flex items-center gap-2 text-zinc-500">
                      <Loader2 size={16} className="animate-spin" />
                      <span>Analyzing...</span>
                    </div>
                )}
                
                {data.structuredResponse && <RiskScorecard analysis={data.structuredResponse} />}
                
                <div className="prose prose-sm dark:prose-invert prose-p:text-zinc-700 dark:prose-p:text-zinc-300 prose-headings:text-zinc-800 dark:prose-headings:text-zinc-200 prose-strong:text-zinc-800 dark:prose-strong:text-zinc-200 prose-a:text-amber-600 dark:prose-a:text-amber-400 selection:bg-amber-500/30">
                  <ReactMarkdown components={{ a: MarkdownLinkRenderer }}>
                    {data.response || ''}
                  </ReactMarkdown>
                  {data.isLoading && (data.response || data.structuredResponse) && <span className="inline-block w-2 h-4 bg-zinc-500 animate-pulse ml-1 rounded-sm" />}
                </div>
            </div>
        )}
      </div>

      <div className="h-14 flex-shrink-0">
        <AnimatePresence>
            {isAnalysisComplete && (
                <motion.div initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0 }} transition={{ duration: 0.2 }} className="border-t border-zinc-200 dark:border-zinc-700 flex items-center justify-center p-2">
                    <button onClick={() => data.createFollowUpNode("Drill down on this risk...", id)} className="p-2 rounded-full text-zinc-500 dark:text-zinc-400 hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-all hover:scale-110 active:scale-95" title="Branch Idea">
                        <Plus size={20} />
                    </button>
                </motion.div>
            )}
        </AnimatePresence>
      </div>

      <Handle type="source" position={Position.Bottom} className="!w-full !h-2 !-bottom-1 !bg-transparent !border-none" />
    </motion.div>
  );
};

export default PitchNode;
// --- FILE: ./src/components/CassandraLogo.tsx ---

// src/components/CassandraLogo.tsx
import React from 'react';
import { cn } from '@/lib/utils';

interface CassandraLogoProps extends React.SVGProps<SVGSVGElement> {
  className?: string;
}

export const CassandraLogo: React.FC<CassandraLogoProps> = ({ className, ...props }) => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      className={cn('h-6 w-6', className)}
      {...props}
    >
      <g fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        {/* The outer 'C' shape representing foresight and analysis */}
        <path d="M21 12a9 9 0 1 1-6.219-8.56" />
        {/* The inner 'spark of insight' */}
        <circle cx="12" cy="12" r="1.5" fill="currentColor" stroke="none" />
      </g>
    </svg>
  );
};

export default CassandraLogo;
// --- FILE: ./src/components/ThemeToggle.tsx ---

// src/components/ThemeToggle.tsx
'use client'

import * as React from 'react'
import { Moon, Sun } from 'lucide-react'
import { useTheme } from 'next-themes'

import { Button } from '@/components/ui/button'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'

export function ThemeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme('light')}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('dark')}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('system')}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
// --- FILE: ./src/components/Logo.tsx ---

"use client";

import React from "react";
import Link from "next/link";
import { Playfair_Display } from "next/font/google";
import { cn } from "@/lib/utils";
import { usePathname } from "next/navigation";
import { CassandraLogo } from "./CassandraLogo"; // Import the SVG logo

const playfair = Playfair_Display({
  subsets: ["latin"],
  weight: "700",
});

interface LogoProps {
  className?: string;
  hideText?: boolean; // Prop to control text visibility
}

export const Logo: React.FC<LogoProps> = ({ className, hideText = false }) => {
  return (
    <Link
      href={"/"}
      className={cn(
        "group flex items-center gap-2.5 transition-opacity duration-300 hover:opacity-80",
        className,
      )}
      aria-label="Cassandra Homepage"
    >
      <CassandraLogo className="h-6 w-6 text-amber-500 shrink-0" />

      <div className={cn("flex flex-col", hideText && "hidden")}>
        <span
          className={cn(
            "text-xl font-bold tracking-tighter leading-none",
            playfair.className
          )}
        >
          Cassandra
        </span>
        <span className="text-xs text-muted-foreground -mt-0.7 ml-1 text-xs">
          Foresight for Founders
        </span>
      </div>
    </Link>
  );
};

export default Logo;
// --- FILE: ./src/components/DashboardContext.tsx ---

// --- FILE: src/components/DashboardContext.tsx ---
"use client";

import React, { createContext, useState, useContext, ReactNode, useEffect, useCallback } from 'react';
import { Node, Edge } from 'reactflow';
import { useDebounce } from '@/hooks/use-debounce';

const LOCAL_STORAGE_KEY = 'cassandra-sessions-v2';

// --- NEW TYPES FOR STRUCTURED RISK DATA ---
export interface Risk {
  risk_name: string;
  score: number;
  summary: string;
}

export interface PitchNodeData {
  pitch: string;
  response?: string | null;
  structuredResponse?: { risk_analysis: Risk[] } | null; // <-- ADDED: For risk scorecard data
  isLoading: boolean;
  contextTitle?: string;
  // These function types are simplified for context definition; their implementation is in the page
  onAnalysis: (nodeId: string, pitch: string, file: File | null) => void;
  createFollowUpNode: (text: string, sourceId: string) => void;
}

// Define a specific Node type for our app
export type CassandraNode = Node<PitchNodeData>;
// --- END OF NEW TYPES ---

export interface Session { 
  id: string; 
  name: string; 
  createdAt: number; 
  nodes: CassandraNode[]; // Use the specific node type
  edges: Edge[]; 
}

interface DashboardContextType {
  sessions: { [id: string]: Session };
  activeSessionId: string | null;
  nodes: CassandraNode[]; // Use the specific node type
  setNodes: React.Dispatch<React.SetStateAction<CassandraNode[]>>;
  edges: Edge[];
  setEdges: React.Dispatch<React.SetStateAction<Edge[]>>;
  loadSession: (id: string) => void;
  newSession: () => void;
  deleteSession: (id: string) => void;
}

const DashboardContext = createContext<DashboardContextType | undefined>(undefined);

export const useDashboard = () => {
  const context = useContext(DashboardContext);
  if (!context) {
    throw new Error('useDashboard must be used within a DashboardProvider');
  }
  return context;
};

export const DashboardProvider = ({ children }: { children: ReactNode }) => {
  const [sessions, setSessions] = useState<{ [id: string]: Session }>({});
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);
  const [nodes, setNodes] = useState<CassandraNode[]>([]); // Use the specific node type
  const [edges, setEdges] = useState<Edge[]>([]);

  const debouncedNodes = useDebounce(nodes, 500);
  const debouncedEdges = useDebounce(edges, 500);
  
  // The rest of this component is identical to your original version
  useEffect(() => {
    const searchParams = new URLSearchParams(window.location.search);
    const pitchFromUrl = searchParams.get('pitch');
    
    const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
    const allSessions = saved ? JSON.parse(saved) : {};
    
    const validSessions = Object.entries(allSessions).reduce((acc, [key, value]) => {
        if (value && typeof value === 'object' && 'id' in value) {
            acc[key] = value as Session;
        }
        return acc;
    }, {} as { [id: string]: Session });

    if (pitchFromUrl) {
      const decodedPitch = decodeURIComponent(pitchFromUrl);
      const id = `s_${Date.now()}`;
      const initialNodes: CassandraNode[] = [{ id: '1', type: 'pitchNode', position: { x: 250, y: 100 }, data: { pitch: decodedPitch, response: null, isLoading: false, onAnalysis: () => {}, createFollowUpNode: () => {} }, }];
      const sessionName = decodedPitch.substring(0, 40).trim() || "Untitled Session";
      const newSessionData: Session = { id, name: sessionName, createdAt: Date.now(), nodes: initialNodes, edges: [] };

      const updatedSessions = { ...validSessions, [id]: newSessionData };
      setNodes(newSessionData.nodes);
      setEdges(newSessionData.edges);
      setActiveSessionId(id);
      setSessions(updatedSessions);
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(updatedSessions));
      window.history.replaceState({}, document.title, window.location.pathname);
      return;
    }

    const recentId = Object.values(validSessions).sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0))[0]?.id;

    if (recentId) {
      const sessionToLoad = validSessions[recentId];
      setNodes(sessionToLoad.nodes);
      setEdges(sessionToLoad.edges);
      setActiveSessionId(recentId);
    } else {
      const id = `s_${Date.now()}`;
      const initialNodes: CassandraNode[] = [{ id: '1', type: 'pitchNode', position: { x: 250, y: 100 }, data: { pitch: '', response: null, isLoading: false, onAnalysis: () => {}, createFollowUpNode: () => {} }, }];
      const newSessionData: Session = { id, name: 'New Session', createdAt: Date.now(), nodes: initialNodes, edges: [] };
      const updatedSessions = { ...validSessions, [id]: newSessionData };
      setNodes(newSessionData.nodes);
      setEdges(newSessionData.edges);
      setActiveSessionId(id);
      setSessions(updatedSessions);
      return;
    }
    setSessions(validSessions);
  }, []);

  const saveSession = useCallback((currentNodes: CassandraNode[], currentEdges: Edge[], sessionId: string | null) => {
    if (!sessionId) return;
    setSessions(prevSessions => {
      if (!prevSessions[sessionId]) { return prevSessions; }
      let sessionName = "Untitled Session";
      if (currentNodes.length > 0 && currentNodes[0].data.pitch) {
        sessionName = currentNodes[0].data.pitch.substring(0, 40).trim() || "Untitled Session";
      }
      const updatedSession: Session = { ...prevSessions[sessionId], name: sessionName, nodes: currentNodes, edges: currentEdges };
      const updatedSessions = { ...prevSessions, [sessionId]: updatedSession };
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(updatedSessions));
      return updatedSessions;
    });
  }, []);

  useEffect(() => {
    if (activeSessionId) {
      saveSession(debouncedNodes, debouncedEdges, activeSessionId);
    }
  }, [debouncedNodes, debouncedEdges, activeSessionId, saveSession]);

  const loadSession = useCallback((id: string) => {
    const sessionToLoad = sessions[id];
    if (sessionToLoad) {
      setNodes(sessionToLoad.nodes);
      setEdges(sessionToLoad.edges);
      setActiveSessionId(id);
    } else {
      console.error(`Attempted to load a session that does not exist: ${id}`);
    }
  }, [sessions]);

  const newSession = useCallback(() => {
    const id = `s_${Date.now()}`;
    const initialNodes: CassandraNode[] = [{ id: '1', type: 'pitchNode', position: { x: 250, y: 100 }, data: { pitch: '', response: null, isLoading: false, onAnalysis: () => {}, createFollowUpNode: () => {} }, }];
    const newSessionData: Session = { id, name: 'New Session', createdAt: Date.now(), nodes: initialNodes, edges: [] };
    
    setNodes(newSessionData.nodes);
    setEdges(newSessionData.edges);
    setActiveSessionId(id);
    
    setSessions(prevSessions => {
      const updatedSessions = { ...prevSessions, [id]: newSessionData };
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(updatedSessions));
      return updatedSessions;
    });
  }, []);
  
  const deleteSession = useCallback((id: string) => {
    setSessions(prevSessions => {
      const { [id]: _, ...remainingSessions } = prevSessions;
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(remainingSessions));
      
      if (activeSessionId === id) {
        const nextSessionToLoad = Object.values(remainingSessions).sort((a, b) => b.createdAt - a.createdAt)[0];

        if (nextSessionToLoad) {
          setNodes(nextSessionToLoad.nodes);
          setEdges(nextSessionToLoad.edges);
          setActiveSessionId(nextSessionToLoad.id);
        } else {
          const newId = `s_${Date.now()}`;
          const initialNodes: CassandraNode[] = [{ id: '1', type: 'pitchNode', position: { x: 250, y: 100 }, data: { pitch: '', response: null, isLoading: false, onAnalysis: () => {}, createFollowUpNode: () => {} }, }];
          const newSessionData: Session = { id: newId, name: 'New Session', createdAt: Date.now(), nodes: initialNodes, edges: [] };
          
          setNodes(newSessionData.nodes);
          setEdges(newSessionData.edges);
          setActiveSessionId(newSessionData.id);
          const finalSessions = { [newId]: newSessionData };
          localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(finalSessions));
          return finalSessions;
        }
      }
      return remainingSessions;
    });
  }, [activeSessionId]);
  
  const value = { sessions, activeSessionId, nodes, setNodes, edges, setEdges, loadSession, newSession, deleteSession };

  return <DashboardContext.Provider value={value}>{children}</DashboardContext.Provider>;
};
// --- FILE: ./src/hooks/use-debounce.ts ---

import { useState, useEffect } from 'react';

// This custom hook takes a value and a delay, and only updates the returned value
// after the delay has passed without the input value changing.
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Set up a timer to update the debounced value after the specified delay
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Clean up the timer if the value changes before the delay has passed
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]); // Only re-run the effect if value or delay changes

  return debouncedValue;
}
// --- FILE: ./src/hooks/use-audio-input.ts ---

// src/hooks/use-audio-input.ts
'use client';

import { useState, useEffect, useRef } from 'react';

// Type guard for SpeechRecognition
interface CustomWindow extends Window {
  SpeechRecognition: any;
  webkitSpeechRecognition: any;
}

export function useAudioInput(onTranscript: (transcript: string) => void) {
  const [isListening, setIsListening] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const recognitionRef = useRef<any>(null);

  useEffect(() => {
    //@ts-expect-error
    const SpeechRecognition = (window as CustomWindow).SpeechRecognition || (window as CustomWindow).webkitSpeechRecognition;
    
    if (!SpeechRecognition) {
      setError("Speech recognition is not supported in this browser.");
      return;
    }

    const recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = 'en-US';

    recognition.onresult = (event: any) => {
      let finalTranscript = '';
      for (let i = event.resultIndex; i < event.results.length; ++i) {
        if (event.results[i].isFinal) {
          finalTranscript += event.results[i][0].transcript;
        }
      }
      if (finalTranscript) {
        onTranscript(finalTranscript);
      }
    };
    
    recognition.onerror = (event: any) => {
        setError(`Speech recognition error: ${event.error}`);
        setIsListening(false);
    };
    
    recognition.onend = () => {
        setIsListening(false);
    };

    recognitionRef.current = recognition;

    return () => {
      recognitionRef.current?.stop();
    };
  }, [onTranscript]);

  const toggleListening = () => {
    if (!recognitionRef.current) return;
    
    if (isListening) {
      recognitionRef.current.stop();
      setIsListening(false);
    } else {
      try {
        recognitionRef.current.start();
        setIsListening(true);
        setError(null);
      } catch (err) {
        setError("Could not start recognition. Please check microphone permissions.");
        setIsListening(false);
      }
    }
  };

  return { isListening, toggleListening, error };
}
// --- FILE: ./src/lib/prisma.ts ---

import { PrismaClient } from "../generated/prisma";

const prismaClientSingleton = () => {
    return new PrismaClient();
}

declare const globalThis: {
    prismaGlobal: ReturnType<typeof prismaClientSingleton>;
} & typeof global;

const prisma = globalThis.prismaGlobal ?? prismaClientSingleton();

export default prisma;

if (process.env.NODE_ENV !== 'production') {
    globalThis.prismaGlobal = prisma;
}
// --- FILE: ./src/lib/utils.ts ---

// src/lib/utils.ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
// --- FILE: ./src/lib/embedding.ts ---

// src/lib/embedding.ts
import OpenAI from 'openai';

// Use a singleton pattern to ensure we only initialize the client once.
let openai: OpenAI | null = null;

const getOpenAIClient = () => {
  if (!openai) {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY is not set in the environment variables.');
    }
    openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
  }
  return openai;
};

/**
 * Generates an embedding for a given text using OpenAI's API.
 * @param text The text to generate an embedding for.
 * @returns A promise that resolves to an array of numbers representing the embedding.
 */
export const generateEmbedding = async (text: string): Promise<number[]> => {
  const client = getOpenAIClient();
  
  // Ensure the input is not empty and replace newlines, which can affect performance.
  const input = text.replace(/\n/g, ' ');

  try {
    const response = await client.embeddings.create({
      model: 'text-embedding-3-small', // Recommended model for cost and performance
      input,
    });

    const embedding = response.data[0].embedding;
    return embedding;
  } catch (error) {
    console.error('Error generating embedding from OpenAI:', error);
    throw new Error('Failed to generate text embedding.');
  }
};
// --- FILE: package.json ---

{
  "name": "cassandra",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint",
    "postinstall": "npx prisma generate"
  },
  "dependencies": {
    "@prisma/client": "^6.15.0",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@react-three/fiber": "^9.3.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.23.12",
    "lucide-react": "^0.542.0",
    "mysql2": "^3.14.4",
    "next": "15.5.2",
    "next-themes": "^0.4.6",
    "openai": "^5.19.1",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-markdown": "^10.1.0",
    "reactflow": "^11.11.4",
    "tailwind-merge": "^3.3.1",
    "three": "^0.180.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/three": "^0.180.0",
    "eslint": "^9",
    "eslint-config-next": "15.5.2",
    "prisma": "^6.15.0",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.8",
    "typescript": "^5"
  }
}

// --- FILE: tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

// --- FILE: prisma/schema.prisma ---

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
  engineType      = "wasm"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// Model for the startup failure data
model StartupFailure {
  id              Int     @id @default(autoincrement())
  companyName     String  @map("company_name")
  
  failureReason   String? @db.Text @map("failure_reason")
  summary         String? @db.Text
  whatTheyDid     String? @db.Text @map("what_they_did")
  whatWentWrong   String? @db.Text @map("what_went_wrong")
  keyTakeaway     String? @db.Text @map("key_takeaway")

  sourceUrl       String? @map("sourceUrl") @db.VarChar(1000) // Good practice to limit URL length
  summary_vector  Json?

  @@fulltext([companyName, failureReason, summary, whatWentWrong])
  @@map("startup_failures")
}

model SearchFrontier {
  id        Int      @id @default(autoincrement())
  query     String   @unique
  status    Status   @default(pending)
  createdAt DateTime @default(now()) @map("created_at")

  @@map("search_frontier")
}

// --- ENUM FOR THE STATUS FIELD ---
enum Status {
  pending
  completed
  failed
}
// --- FILE: .env.example ---

MOONSHOT_API_KEY=

DATABASE_URL=

OPENAI_API_KEY=
// --- FILE: ./data-agent/main.py ---

import os
import asyncio
import json
from typing import List, Dict, Any, Set

import google.generativeai as genai
from openai import AsyncOpenAI
from tavily import TavilyClient
import mysql.connector.aio
from mysql.connector.aio import pooling
from dotenv import load_dotenv
import certifi

# --- Configuration ---
load_dotenv()
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
tavily = TavilyClient(api_key=os.getenv("TAVILY_API_KEY"))
openai_client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))
tidb_config = {
    'host': os.getenv('TIDB_HOST'),
    'port': int(os.getenv('TIDB_PORT', 4000)),
    'user': os.getenv('TIDB_USER'),
    'password': os.getenv('TIDB_PASSWORD'),
    'database': os.getenv('TIDB_DATABASE'),
    'ssl_ca': "/etc/ssl/cert.pem",
    'ssl_verify_cert': True,
    'ssl_verify_identity': True,
}

connection = None
try:
    # Use the SYNCHRONOUS connector for a clearer error message
    connection = mysql.connector.connect(**tidb_config)
    
    if connection.is_connected():
        print("\n✅✅✅ SUCCESS: Database connection established! ✅✅✅")
        cursor = connection.cursor()
        cursor.execute("SELECT VERSION();")
        record = cursor.fetchone()
        print(f"Database version: {record[0]}")
        cursor.close()
    else:
        print("\n❌❌❌ FAILURE: Connection object created, but not connected. ❌❌❌")

except mysql.connector.Error as err:
    print(f"\n❌❌❌ FAILURE: A mysql.connector error occurred: {err} ❌❌❌")
    print("--- DEBUGGING CHECKLIST ---")
    print("1. Is your IP address whitelisted in the TiDB Cloud console?")
    print("2. Are the HOST, USER, and PASSWORD in your .env file 100% correct (no typos, no extra spaces)?")
    print("3. Is your cluster 'Available' and not 'Paused' or 'Creating'?")

finally:
    if connection and connection.is_connected():
        connection.close()
        print("\nConnection closed.")

# --- Agent Parameters ---
RESEARCH_ITERATIONS = 10
BATCH_SIZE = 5
SEMAPHORE = asyncio.Semaphore(5)  # Reduced from 10 to be more conservative
SEED_TOPICS = [
    "Y Combinator startup post-mortems", "TechCrunch deadpool analysis",
    "CB Insights startup failure reports", "failed SaaS companies 2022",
    "post-mortems of venture-backed startups", "failed fintech startups analysis",
    "why did D2C brands shut down", "biggest gaming startup failures",
    "failed HealthTech companies case studies", "top EdTech startup failures"
]

# Global pool variable
db_pool = None

async def get_db_connection():
    """Get a database connection with proper error handling and debugging"""
    global db_pool
    try:
        conn = await db_pool.get_connection()
        print(f"🔗 Got connection. Pool stats: {db_pool.pool_size - len(db_pool._cnx_queue._queue)} connections in use")
        return conn
    except Exception as e:
        print(f"❌ Failed to get connection: {e}")
        print(f"Pool size: {db_pool.pool_size}, Queue size: {len(db_pool._cnx_queue._queue)}")
        raise

async def safe_close_connection(conn):
    """Safely close a database connection"""
    try:
        if conn and conn.is_connected():
            await conn.close()
            print("🔌 Connection closed successfully")
    except Exception as e:
        print(f"⚠️ Error closing connection: {e}")

# --- Agent Components ---
async def seed_frontier():
    """Seed the research frontier with initial topics"""
    print("🌱 Seeding the research frontier...")
    conn = None
    try:
        conn = await get_db_connection()
        async with await conn.cursor() as cursor:
            for topic in SEED_TOPICS:
                await cursor.execute("INSERT IGNORE INTO search_frontier (query, status) VALUES (%s, 'pending')", (topic,))
            await conn.commit()
        print("✅ Frontier seeded.")
    except Exception as e:
        print(f"❌ Error seeding frontier: {e}")
        raise
    finally:
        await safe_close_connection(conn)

async def fetch_tasks_from_frontier(limit: int) -> List[str]:
    """Fetch pending tasks from the frontier"""
    conn = None
    try:
        conn = await get_db_connection()
        async with await conn.cursor(dictionary=True) as cursor:
            await cursor.execute("SELECT query FROM search_frontier WHERE status = 'pending' LIMIT %s", (limit,))
            tasks = await cursor.fetchall()
            return [task['query'] for task in tasks]
    except Exception as e:
        print(f"❌ Error fetching tasks: {e}")
        return []
    finally:
        await safe_close_connection(conn)

async def analyst_agent(query: str, search_results: List[Dict]) -> List[Dict]:
    """UPGRADED Analyst Stage: Extracts detailed data including the source URL."""
    print(f"  -> Analyzing (Pro): {query}")
    model = genai.GenerativeModel('gemini-1.5-pro-latest', generation_config={"response_mime_type": "application/json"})
    
    # Context now includes a clear 'Source URL' for each piece of content
    context = "\n\n".join([f"Source URL: {res['url']}\nContent: {res['content']}" for res in search_results])
    
    prompt = f"""
        You are a meticulous business analyst. Your task is to analyze the provided web search results about failed startups for the query "{query}".
        From the context, identify all distinct failed startups and extract detailed information for each one. For each failure, you MUST include its original source URL.

        Your output MUST be a valid JSON object with a single key "failures", which is a list of objects.
        Each object in the list MUST have the following SIX keys:
        1.  "company_name": string
        2.  "failure_reason_category": string
        3.  "what_they_did": string
        4.  "what_went_wrong": string
        5.  "key_takeaway": string
        6.  "source_url": string  // <-- ADDED KEY: The URL from the 'Source URL' line in the context.

        IMPORTANT: Ensure all string values are properly escaped for valid JSON output.

        Context from web search:
        ---
        {context[:100000]} 
        ---
    """
    try:
        response = await model.generate_content_async(prompt)
        # Clean the response text to ensure it's valid JSON
        cleaned_text = response.text.strip().replace("```json", "").replace("```", "")
        return json.loads(cleaned_text).get("failures", [])
    except Exception as e:
        print(f"  -> ❌ Analyst Agent Error for '{query}': {e}")
        return []

async def expand_frontier(new_cases: List[Dict]):
    """Expand the search frontier with new queries"""
    if not new_cases: 
        return
    
    print("🧠 Expanding frontier with new, more specific search queries...")
    model = genai.GenerativeModel('gemini-1.5-pro-latest')
    context = "\n".join([f"- {case['company_name']}: {case.get('what_went_wrong', case.get('summary', ''))}" for case in new_cases[:10]])
    prompt = f"""
    Based on these summaries of recently discovered failed startups, generate 5 new, highly specific search queries to find similar stories or dig deeper.
    Return a simple list of queries, one per line.
    Discovered startups: --- {context} ---
    """
    
    conn = None
    try:
        response = await model.generate_content_async(prompt)
        new_queries = [q.strip() for q in response.text.split('\n') if q.strip() and not q.strip().startswith('-')]
        
        conn = await get_db_connection()
        async with await conn.cursor() as cursor:
            for query in new_queries:
                await cursor.execute("INSERT IGNORE INTO search_frontier (query, status) VALUES (%s, 'pending')", (query,))
            await conn.commit()
        print(f"✅ Added {len(new_queries)} new queries to the frontier.")
        
    except Exception as e:
        print(f"  -> ❌ Expand Frontier Error: {e}")
    finally:
        await safe_close_connection(conn)

async def loader_task(case: Dict, existing_companies: Set[str]):
    """Load a single case into the database"""
    company_name = case.get("company_name", "").strip()
    if not company_name or company_name.lower() in existing_companies:
        return 0
    
    text_to_embed = case.get("what_went_wrong")
    if not text_to_embed:
        return 0

    conn = None
    try:
        # Get embedding first (no DB connection needed)
        embedding_response = await openai_client.embeddings.create(model="text-embedding-3-small", input=text_to_embed)
        embedding = embedding_response.data[0].embedding
        
        # Then handle database operation
        conn = await get_db_connection()
        async with await conn.cursor() as cursor:
            await cursor.execute(
                """
                INSERT INTO startup_failures 
                (company_name, failure_reason, summary, what_they_did, what_went_wrong, key_takeaway, sourceUrl, summary_vector) 
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """,
                (
                    company_name, 
                    case.get('failure_reason_category'), 
                    case.get('what_they_did'), # Using detailed field as summary
                    case.get('what_they_did'), 
                    case.get('what_went_wrong'), 
                    case.get('key_takeaway'),
                    case.get('source_url'),    # <-- ADDED VALUE
                    json.dumps(embedding)
                )
            )
            await conn.commit()
        print(f"    -> ✅ Stored: {company_name} (from {case.get('source_url')})")
        return 1
        
    except Exception as e:
        print(f"    -> ❌ Loader Error for '{company_name}': {e}")
        return 0
    finally:
        await safe_close_connection(conn)

async def get_existing_companies() -> Set[str]:
    """Get existing companies from database"""
    conn = None
    try:
        conn = await get_db_connection()
        async with await conn.cursor() as cursor:
            await cursor.execute("SELECT LOWER(company_name) FROM startup_failures")
            result = await cursor.fetchall()
            return {row[0] for row in result}
    except Exception as e:
        print(f"❌ Error getting existing companies: {e}")
        return set()
    finally:
        await safe_close_connection(conn)

async def update_completed_tasks(tasks_to_run: List[str]):
    """Update task status to completed"""
    conn = None
    try:
        conn = await get_db_connection()
        async with await conn.cursor() as cursor:
            for query in tasks_to_run:
                await cursor.execute("UPDATE search_frontier SET status = 'completed' WHERE query = %s", (query,))
            await conn.commit()
    except Exception as e:
        print(f"❌ Error updating completed tasks: {e}")
    finally:
        await safe_close_connection(conn)

async def reset_agent_state():
    """Reset agent state for a fresh run"""
    print("🧹 Resetting agent state for a fresh run...")
    conn = None
    try:
        conn = await get_db_connection()
        async with await conn.cursor() as cursor:
            await cursor.execute("DELETE FROM search_frontier")
            await conn.commit()
    except Exception as e:
        print(f"❌ Error resetting agent state: {e}")
        raise
    finally:
        await safe_close_connection(conn)

# --- Main Orchestrator ---
async def main():
    global db_pool
    total_startups_found = 0  # Initialize at the top
    
    print("--- Starting Cassandra Industrial Research Agent (URL-Aware Edition) ---")
    
    try:
        # Create connection pool with more conservative settings
        db_pool = pooling.MySQLConnectionPool(
            pool_name="tidb_pool", 
            pool_size=5,  # Reduced from 10
            pool_reset_session=True,
            **tidb_config
        )
        print("✅ Database connection pool created.")

        # Test connection first
        test_conn = await get_db_connection()
        await safe_close_connection(test_conn)
        print("✅ Database connection test successful.")

        # Reset and seed with proper connection handling
        await reset_agent_state()
        await seed_frontier()
        
        for i in range(RESEARCH_ITERATIONS):
            print(f"\n--- 🔄 Starting Research Iteration {i+1}/{RESEARCH_ITERATIONS} ---")
            
            # Get existing companies and tasks
            existing_companies = await get_existing_companies()
            initial_count = len(existing_companies)
            tasks_to_run = await fetch_tasks_from_frontier(BATCH_SIZE)
            
            if not tasks_to_run:
                print("🏁 No more tasks in the frontier. Agent has completed its mission.")
                break

            async def research_and_analyze_task(query):
                async with SEMAPHORE:
                    try:
                        results = await asyncio.to_thread(tavily.search, query=query, search_depth="advanced", max_results=7)
                        if not results or not results.get('results'): 
                            return []
                        return await analyst_agent(query, results['results'])
                    except Exception as e:
                        print(f"  -> ❌ Research Error for '{query}': {e}")
                        return []

            # Execute research tasks
            pipeline_tasks = [research_and_analyze_task(query) for query in tasks_to_run]
            results_from_pipelines = await asyncio.gather(*pipeline_tasks, return_exceptions=True)
            
            # Handle exceptions in results
            all_new_cases = []
            for result in results_from_pipelines:
                if isinstance(result, Exception):
                    print(f"  -> ❌ Pipeline task failed: {result}")
                else:
                    all_new_cases.extend(result)

            print(f"  -> Found {len(all_new_cases)} potential cases. Loading new ones into TiDB...")
            
            # Load cases with limited concurrency
            loader_tasks = [loader_task(case, existing_companies) for case in all_new_cases]
            results = await asyncio.gather(*loader_tasks, return_exceptions=True)
            
            # Count successful insertions
            newly_added_count = sum(r for r in results if isinstance(r, int) and r > 0)
            total_startups_found += newly_added_count
            print(f"  -> Stored {newly_added_count} new startups. Total in DB: {initial_count + newly_added_count}")

            # Update completed tasks and expand frontier
            await update_completed_tasks(tasks_to_run)
            await expand_frontier(all_new_cases)

    except Exception as e:
        print(f"❌ Main loop error: {e}")
        import traceback
        traceback.print_exc()
    finally:
        print(f"\n--- AGENT FINISHED - Total startups found: {total_startups_found} ---")

if __name__ == "__main__":
    asyncio.run(main())
// --- FILE: ./data-agent/README.md ---

# Cassandra Research Agent 

An autonomous AI research agent that continuously discovers, analyzes, and catalogues startup failure stories from across the web. Named after Cassandra of Troy, who could see the future but was cursed to never be believed - this agent helps entrepreneurs learn from the past to avoid repeating it.

## 🎯 What It Does

The Cassandra Agent operates as a **self-expanding research system** that:

### 1. **Intelligent Web Discovery**
- Starts with seed topics about startup failures and post-mortems
- Uses advanced web search to find relevant articles, blog posts, and reports
- Dynamically generates new search queries based on discovered patterns
- Maintains a "research frontier" of unexplored topics

### 2. **AI-Powered Analysis**
- Extracts detailed failure stories from web content using Google Gemini
- Identifies specific companies, failure reasons, and key takeaways
- Categorizes failures by type (product-market fit, funding, execution, etc.)
- Preserves source URLs for verification and deeper research

### 3. **Semantic Knowledge Base**
- Stores findings in TiDB with vector embeddings for semantic search
- Prevents duplicate entries while building comprehensive coverage
- Creates structured data from unstructured web content
- Enables similarity-based discovery of related failure patterns

### 4. **Autonomous Operation**
- Runs continuously without human intervention
- Self-expands research scope based on discoveries
- Manages rate limits and API quotas intelligently
- Handles errors and connection issues gracefully

## 🏗️ Architecture

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────────┐
│   Web Search    │───▶│   AI Analysis    │───▶│   Vector Storage    │
│   (Tavily)      │    │   (Gemini Pro)   │    │     (TiDB)          │
└─────────────────┘    └──────────────────┘    └─────────────────────┘
         ▲                       │                        │
         │                       ▼                        │
┌─────────────────┐    ┌──────────────────┐               │
│ Query Generator │◀───│ Pattern Analysis │◀──────────────┘
│   (Gemini)      │    │   (Discovery)    │
└─────────────────┘    └──────────────────┘
```

## 📊 Data Schema

Each discovered startup failure includes:

```json
{
  "company_name": "string",
  "failure_reason_category": "string", 
  "what_they_did": "string",
  "what_went_wrong": "string", 
  "key_takeaway": "string",
  "source_url": "string",
  "summary_vector": "float[]"
}
```

## 🚀 Getting Started

### Prerequisites

- Python 3.9+
- TiDB database (local or cloud)
- API keys for:
  - Google AI (Gemini)
  - Tavily Search
  - OpenAI (for embeddings)

### Installation

```bash
# Clone and setup
git clone <repository>
cd cassandra-agent
uv venv
source .venv/bin/activate
uv pip install -r requirements.txt
```

### Configuration

Create `.env` file:

```env
# Database
TIDB_HOST=your-tidb-host
TIDB_PORT=4000
TIDB_USER=your-username
TIDB_PASSWORD=your-password
TIDB_DATABASE=your-database

# API Keys
GOOGLE_API_KEY=your-gemini-key
TAVILY_API_KEY=your-tavily-key
OPENAI_API_KEY=your-openai-key
```

### Database Setup

```sql
-- Create tables
CREATE TABLE search_frontier (
    id INT AUTO_INCREMENT PRIMARY KEY,
    query VARCHAR(500) UNIQUE,
    status ENUM('pending', 'completed') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE startup_failures (
    id INT AUTO_INCREMENT PRIMARY KEY,
    company_name VARCHAR(255),
    failure_reason VARCHAR(500),
    summary TEXT,
    what_they_did TEXT,
    what_went_wrong TEXT,
    key_takeaway TEXT,
    sourceUrl VARCHAR(1000),
    summary_vector JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX(company_name)
);
```

### Running the Agent

```bash
uv run main.py
```

## 🎛️ Configuration Options

```python
# Agent Parameters
RESEARCH_ITERATIONS = 10    # Max research cycles
BATCH_SIZE = 5             # Queries per iteration
SEMAPHORE = asyncio.Semaphore(5)  # Concurrent operations limit

# Seed topics - customize for your research focus
SEED_TOPICS = [
    "Y Combinator startup post-mortems",
    "TechCrunch deadpool analysis",
    "CB Insights startup failure reports",
    # Add your own topics...
]
```

## 📈 Sample Output

```
--- Starting Cassandra Industrial Research Agent ---
🌱 Seeding the research frontier...
✅ Frontier seeded.

--- 🔄 Starting Research Iteration 1/10 ---
  -> Analyzing (Pro): Y Combinator startup post-mortems
  -> Found 12 potential cases. Loading new ones into TiDB...
    -> ✅ Stored: Homejoy (from https://techcrunch.com/...)
    -> ✅ Stored: Zirtual (from https://medium.com/...)
  -> Stored 8 new startups. Total in DB: 8

🧠 Expanding frontier with new search queries...
✅ Added 5 new queries to the frontier.
```

## 🔍 What You'll Discover

The agent typically finds:

- **Product-Market Fit Failures**: Companies that built something nobody wanted
- **Funding & Cash Flow Issues**: Startups that ran out of money
- **Execution Problems**: Good ideas, poor implementation
- **Market Timing**: Too early or too late to market
- **Team Dynamics**: Co-founder conflicts and leadership issues
- **Competition**: Outmaneuvered by larger players
- **Pivot Failures**: Unsuccessful attempts to change direction

## 🛡️ Features

### Intelligent Deduplication
- Prevents storing the same company multiple times
- Uses fuzzy matching on company names
- Maintains data quality and uniqueness

### Source Attribution
- Every failure story includes its source URL
- Enables fact-checking and deeper research
- Maintains transparency and credibility

### Semantic Search Ready
- Vector embeddings enable "find similar failures"
- Can discover patterns across different industries
- Supports building recommendation systems

### Fault Tolerant
- Handles API rate limits gracefully
- Recovers from network errors
- Manages database connection pooling
- Logs errors without stopping the research

## 📚 Use Cases

### For Entrepreneurs
- Learn from others' mistakes before making your own
- Identify common failure patterns in your industry
- Validate assumptions against historical data

### For Investors
- Due diligence research on market risks
- Pattern recognition for investment decisions
- Portfolio company risk assessment

### For Researchers
- Academic studies on entrepreneurship
- Failure pattern analysis across industries
- Building predictive models for startup success

### For Content Creators
- Rich source material for articles and videos
- Data-driven insights on startup ecosystems
- Trend analysis and market intelligence

## 🔮 Future Enhancements

- **Industry Classification**: Auto-categorize failures by sector
- **Timeline Analysis**: Track failure patterns over time
- **Sentiment Analysis**: Measure emotional tone of failure stories
- **Network Effects**: Map connections between failed startups
- **Predictive Modeling**: Early warning systems for current startups

## ⚠️ Limitations

- **Data Quality**: Dependent on publicly available information
- **Bias**: May overrepresent well-documented failures
- **Recency**: Some historical failures may be under-represented
- **Attribution**: Source quality varies across the web

## 🤝 Contributing

This agent is designed to be extensible:

1. **Add New Sources**: Modify search strategies for specific data sources
2. **Improve Analysis**: Enhance the AI prompts for better extraction
3. **New Categories**: Add failure classification categories
4. **Export Features**: Build dashboards and reporting tools

*"Those who cannot remember the past are condemned to repeat it."* - George Santayana

Let Cassandra help you learn from the futures that never were.